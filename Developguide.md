스타트업쇼 개발 가이드 문서 세트
1. 제품 비전 문서 (Product Vision Document)
비전 개요: 스타트업쇼는 스타트업 운영 업무를 자동화하여 창업팀이 핵심 비즈니스에 집중할 수 있도록 돕는 플랫폼입니다. 초기 스타트업은 한정된 인력으로 사업 개발, 투자 유치, 행정 업무까지 수행해야 하는데, 스타트업쇼는 이러한 반복적 운영 작업을 효율화하고 투자자 소통을 지원하는 통합 솔루션을 제공합니다. AI 기술과 Vibe Coding 개발 방식(인간 개발자와 AI 에이전트의 협업)을 적극 활용하여 적은 인원으로도 빠르게 개발 및 서비스 개선을 이루는 것을 목표로 합니다 .
해결하려는 문제: 많은 스타트업들이 프로젝트 관리, 팀 커뮤니케이션, 투자자 보고 등 운영 업무에 과도한 시간을 소모합니다. 자료가 여러 도구에 분산되고, 투자 현황 공유나 VC 매칭이 원활하지 않아 성장에 제약이 됩니다. 스타트업쇼는 하나의 플랫폼에서 스타트업 운영의 모든 측면을 관리하고 자동화하여, 운영 효율 극대화와 성장 가속을 돕습니다.
제품 가치 제안: 스타트업쇼는 세 가지 핵심 가치를 제공합니다:
운영 효율화: 일정/과제 관리, 문서 정리, 보고 생성 등의 작업을 자동화하고 템플릿화하여 운영 부담을 경감시킵니다. 예를 들어 자동 리마인더와 반복 업무 자동 생성으로 누락 없이 업무를 수행합니다.


투자자 커뮤니케이션 강화: 스타트업의 주요 지표 대시보드, 투자자 보고서 공유, 데이터룸 기능 등을 통해 투자자들과의 신뢰 형성을 돕습니다. 접근 권한 제어로 민감 정보는 보호하면서 필요한 정보는 실시간 제공됩니다.


AI 기반 인사이트: 내장된 AI 어시스턴트가 스타트업 운영 노하우를 제공하고, 입력된 데이터를 분석해 의사결정 인사이트를 줍니다. 예를 들어, AI가 월간 성과를 요약해 투자자 업데이트 초안을 작성하거나, 질의응답을 통해 스타트업 관련 질문에 대한 정확한 답변을 제공합니다.


목표 사용자: 초기 스타트업 창업자 및 팀원, 그리고 이들과 교류하는 VC/엔젤 투자자가 주요 사용자입니다. 창업팀에게는 운영업무 자동화를, 투자자에게는 투자사 포트폴리오 모니터링 및 유망 스타트업 탐색을 지원합니다. 플랫폼의 장기적 비전은 스타트업과 투자자 간의 생태계 허브로 성장하여, 스타트업 운영 데이터와 네트워크를 기반으로 맞춤형 매칭과 성장 지원을 제공하는 것입니다.
핵심 지표: 성공을 판단할 주요 지표는 사용 기업 수, 활성 팀원 수, 주간 플랫폼 상 상호작용(생성된 과제, 업데이트 발행 건수 등), 투자자 열람 세션 수, 매칭된 투자 유치 건수 등입니다. 이러한 지표들을 통해 플랫폼이 스타트업 운영 효율과 투자 연결에 얼마나 기여하는지 평가합니다.
2. 시스템 개요 문서 (System Overview Document)
시스템 아키텍처 개요: 스타트업쇼는 웹 기반 SaaS 플랫폼으로, 프런트엔드(웹 UI), 백엔드 API 서버, 데이터베이스, AI 모듈의 다층 구조로 이루어져 있습니다. 사용자(스타트업 팀원 및 투자자)는 웹 브라우저나 모바일 기기에서 서비스를 이용하며, RESTful API를 통해 서버와 통신합니다. 전체 시스템은 클라우드 환경에 배포되어 확장성과 가용성을 확보하고 있습니다.
클라이언트(프런트엔드): React 등 SPA 프레임워크로 구현된 웹 어플리케이션으로, 대시보드, 과제 관리 보드, 투자자 페이지 등의 UI를 제공합니다. 주요 기능에 대해 동적이고 반응형인 UX를 제공하며, 필요 시 실시간 알림(WebSocket 또는 Server-Sent Events)으로 과제 상태나 알림을 갱신합니다.


백엔드(API 서버): Node.js 기반의 REST API 서버로, 인증/인가, 비즈니스 로직, DB 액세스를 담당합니다. Express 또는 NestJS 프레임워크로 구축되어 **계층화된 아키텍처(컨트롤러-서비스-DAO)**를 따르고 있습니다. 백엔드는 JWT 인증을 사용해 각 요청을 인증하고 사용자 권한(Role)에 따라 접근을 제어합니다.


데이터베이스: 운영 데이터는 관계형 DB(예: PostgreSQL)로 관리되며, 사용자 계정, 스타트업 프로필, 과제, 업데이트, 접근 권한 등의 정형 데이터를 저장합니다. 또한 AI 벡터 검색용 DB(예: Pinecone 또는 Qdrant)도 별도로 존재하여, 문서 임베딩 데이터를 저장하고 RAG를 구현합니다.


AI 모듈: AI 어시스턴트 및 에이전트 기능을 지원하는 마이크로서비스 또는 백엔드의 모듈로 존재합니다. 이 모듈은 OpenAI GPT-4와 같은 대형 언어 모델(LLM) API와 연동되며, 사용자의 자연어 질의에 응답하거나 자동화 작업을 수행합니다. AI 모듈은 벡터 DB와 지식 베이스를 참조하여 **컨텍스트 기반 응답(RAG 구조)**을 생성합니다 . 또한 필요 시 내부 API를 호출하여 실제 작업(예: 새로운 과제 생성)을 수행하는 에이전트 역할도 맡습니다.


외부 연동: 이메일 발송(SendGrid 등), 캘린더 연동(Google Calendar API), 파일 스토리지(AWS S3) 등의 외부 서비스와 통합되어 사용자에게 원활한 기능 연계를 제공합니다. 예를 들어, 투자자 초대 수락 시 자동으로 알림 이메일이 발송되거나, 데이터룸 파일이 클라우드 스토리지에 안전하게 저장됩니다.


배포 환경: 전체 시스템은 AWS 클라우드에 배포되며, Docker 컨테이너로 패키징되어 있습니다. API 서버와 AI 모듈은 Kubernetes(EKS) 상에서 마이크로서비스로 동작하거나, 초기 단계에서는 단일 서버 내에서 모듈화된 모놀리식 형태로 운영됩니다. PostgreSQL은 AWS RDS로 관리되고, 벡터 DB는 SaaS(Pinecone 등) 또는 자체 클러스터로 구성됩니다. 이러한 설계로 트래픽 증가 시 각 구성요소를 독립적으로 확장할 수 있고, 장애 발생 시 영향을 격리합니다.
전체 데이터 흐름: 일반적인 시나리오에서, 사용자가 웹 UI에서 요청을 하면 API 서버가 이를 받아 업무 로직 처리 및 DB 질의를 수행하고, 필요한 경우 AI 모듈에 작업을 위임합니다. 이후 API 서버는 결과를 JSON 형태로 응답하며, 클라이언트는 이를 화면에 반영합니다. AI 관련 요청의 경우, API 서버가 AI 모듈을 호출하여 벡터 DB 검색→LLM 응답 생성→결과 반환의 단계를 거칩니다. 시스템 전반에 로그잉/모니터링이 적용되어, 요청 추적이나 오류 진단이 가능하며, 중요한 이벤트(예: 권한 승인)는 감사 로그로 남겨 안전한 운영을 도모합니다.
3. 기능 정의서 (Feature Specification)
스타트업쇼의 주요 기능은 스타트업 팀용 기능과 투자자용 기능으로 구분되며, 각 기능의 세부 동작은 아래와 같습니다.
사용자 등록 및 온보딩: 이메일 및 비밀번호로 가입하거나 OAuth 소셜 로그인을 지원합니다. 창업자는 회원가입 시 스타트업 프로필 생성 과정을 거쳐 회사 정보를 입력하며, 팀원을 초대할 수 있습니다. 투자자는 가입 후 투자자 프로필(소속 펀드, 관심 분야 등)을 설정합니다. 온보딩 절차에서 단계별 안내를 제공하여 원활한 초기 설정을 돕습니다.


권한 기반 접근 제어: 역할(Role)에 따라 UI 및 기능 노출을 제어합니다. 스타트업 계정(창업자/팀원)은 자기 회사의 데이터만 볼 수 있고 편집 가능하며, 투자자 계정은 초대를 수락하거나 권한이 승인된 스타트업의 데이터만 열람 전용으로 볼 수 있습니다. 관리자(Admin)는 모든 데이터를 관리할 수 있는 별도 계정입니다.


대시보드 (Dashboard): 로그인 후 진입하는 메인 화면으로, 스타트업팀에게는 주요 지표(KPI) 요약, 진행 중인 과제, 최근 업데이트, 알림 등을 한눈에 보여줍니다. 투자자에게는 관심 스타트업 목록, 각 스타트업의 최신 지표 추세, 새 업데이트 알림 등이 표시됩니다. 대시보드는 위젯 구성으로 사용자 역할에 맞게 다른 정보를 표시합니다.


프로젝트/과제 관리: 스타트업 운영상의 To-do나 프로젝트를 관리하기 위한 기능입니다. Kanban 보드 형태의 과제 관리 보드를 제공하여, **과제 생성, 담당자 지정, 마감일 설정, 상태 이동(예: 예정→진행중→완료)**을 지원합니다. 반복적인 주기성 업무는 자동 생성 템플릿으로 관리할 수 있습니다. 또한 마감일 도래 시 알림 발송, 지연 과제에 대한 하이라이트 표시 등으로 팀원들이 일정에 맞게 업무를 처리하도록 돕습니다.


팀 및 권한 관리: 스타트업 관리자는 팀원 초대(이메일 초대 링크) 및 권한 부여를 할 수 있습니다. 예를 들어, 편집 권한이 없는 뷰어 역할의 팀원을 정의하거나, 특정 민감 정보(재무 데이터 등)에 대한 접근 제한을 설정할 수 있습니다. 투자자 초대 및 승인도 이 모듈에서 이루어집니다 (투자자 권한 관리 기능은 아래 별도 설명).


스타트업 프로필 및 데이터룸: 각 스타트업 별로 회사 프로필 페이지가 있습니다. 이 페이지에는 회사 개요(비전, 팀, 제품 설명), 핵심 지표(예: MRR, 사용자 수 성장), **자료실(데이터룸)**이 포함됩니다. 데이터룸에는 투자자 공유용 문서(PDF 사업계획서, 재무제표 등)를 업로드하여 관리할 수 있고, 권한이 있는 투자자만 해당 문서를 열람하거나 다운로드할 수 있습니다. 모든 파일은 접근 권한이 필요한 보안 경로로 제공되며, 조회 이력이 기록됩니다.


투자자 업데이트 (IR 보고): 창업팀이 정기적으로 투자자들에게 회사 현황을 공유할 수 있는 기능입니다. 월간 업데이트나 분기 리포트를 마크다운 에디터 또는 폼 형식으로 작성하고, 이전 데이터(지난 분기 수치 등)를 불러와 비교 표시할 수 있습니다. 작성된 업데이트는 버튼 클릭 한 번으로 투자자들에게 공유되며, 승인된 투자자는 웹에서 실시간 열람하거나 이메일 첨부로 받을 수 있습니다. AI 어시스턴트가 주요 성과를 요약하거나 보고서 문안을 다듬는 데 도움을 주어, 전문적이고 간결한 보고를 작성하도록 지원합니다.


AI 어시스턴트 (Chatbot) 기능: 플랫폼 내에 챗봇 인터페이스로 제공되는 AI 비서가 존재합니다. 스타트업 팀원은 자연어로 “이번 달 마케팅 성과 요약해줘”와 같은 요청을 할 수 있고, AI는 관련 데이터를 분석하여 요약 응답을 제공합니다. 또한 “다음 주 해야 할 주요 업무 알려줘” 같은 질의에 대해 과거 작업 이력을 참고하여 우선순위 과제 제안도 가능하도록 설계합니다. 투자자는 “ABC스타트업의 지난 달 매출은?“과 같이 질문하면 해당 데이터(권한 범위 내)로부터 답변을 받을 수 있습니다. 이러한 질의응답 및 업무 자동화 기능은 벡터 DB의 회사 데이터와 일반 스타트업 지식베이스를 활용한 RAG로 구현되어, 최신 정보와 맥락에 기반한 정확한 답변을 제공합니다 .


알림 및 일정 통합: 플랫폼에서 발생하는 중요한 이벤트(예: 투자자 접근 요청, 과제 마감, 팀원 멘션 등)에 대해 실시간 알림을 지원합니다. 웹 알림센터와 함께 선택적으로 이메일, Slack 연동을 통해 알림을 받을 수 있습니다. 또한 캘린더(SaaS 캘린더 API 연동)와 통합하여 투자자 미팅 일정이나 프로젝트 마일스톤 일정을 플랫폼 내에서 확인하고 관리할 수 있습니다.


투자자용 검색 및 매칭: 투자자는 플랫폼에서 스타트업 검색을 통해 관심 분야(산업, 단계, 지역 등) 필터로 공개된 스타트업 프로필을 찾아볼 수 있습니다. 스타트업 이름, 분야 등의 키워드 검색도 지원됩니다. 더불어 매칭 추천 엔진이 투자자의 프로필(선호 투자 분야, 과거 투자 내역)을 바탕으로 잠재적으로 관심 가질만한 스타트업 목록을 추천합니다. 이 추천 목록은 알고리즘을 통해 스타트업-VC 간의 적합도를 계산하여 제안됩니다 (매칭 로직은 후술). 투자자는 관심 목록에 추가하거나, 바로 접근 요청을 보낼 수 있습니다.


투자자 열람 & 권한 승인: 스타트업 관리자는 투자자의 프로필 및 요청 내역을 검토하고, 적절한 경우 투자자에게 자사 정보 열람 권한을 부여할 수 있습니다. 권한 승인 워크플로우를 통해 투자자가 요청을 보내면, 관리자가 승인/거부를 수행하며, 승인 시 해당 투자자는 그 스타트업의 대시보드, 데이터룸, 업데이트를 읽기 전용으로 볼 수 있게 됩니다. 권한 부여 현황은 언제든 철회(revoke) 가능하고, 권한 부여시 NDA 동의 절차를 포함할 수도 있습니다. (해당 흐름은 “투자자 열람 시스템 및 권한 흐름” 문서에 상세).


관리자(Admin) 기능: 플랫폼 운영자를 위한 관리자 콘솔이 존재합니다. 전체 사용자 관리(이상 활동 모니터링, 계정 차단 등), 시스템 설정(예: 금지어 필터, 공지사항 배포), 로그 조회 및 데이터 백업 등의 기능이 포함됩니다. 또한 콘텐츠 관리로서 FAQ나 도움말 문서를 편집하여 플랫폼 내 AI 지식베이스에 추가하는 기능도 있습니다. 관리자 계정은 내부 운영팀만 가지며, 일반 스타트업/투자자와 분리된 인터페이스로 제공됩니다.


각 기능은 UI/UX 설계, 권한 검증, 데이터 흐름 측면에서 상세 사양에 따라 구현됩니다. 이후 UX 흐름도 문서와 UI 와이어프레임 설명에서 주요 기능의 사용 흐름과 화면 구성을 다루며, 기술 아키텍처 문서에서 기능 구현을 뒷받침하는 구조를 설명합니다.
4. UX 흐름도 (UX Flowcharts)
주요 사용자 시나리오 별로 UX 흐름을 도식화하여, 사용 단계에서의 사용자 동작과 시스템 반응을 정의합니다. 여기서는 스타트업쇼의 핵심 UX 흐름 몇 가지를 서술합니다:
1. 스타트업 회원 온보딩 흐름:
회원가입: 사용자는 웹 사이트에서 이메일과 비밀번호로 계정을 생성합니다. 가입 시 이메일 인증 절차를 거쳐 계정이 활성화됩니다.


스타트업 프로필 생성: 창업자는 로그인 후 새 스타트업 생성 화면으로 이동합니다. 회사 이름, 업종, 단계, 소개 등을 입력하고 프로필 생성을 완료합니다.


팀원 초대: 프로필 생성 후 바로 팀원 초대 단계가 나타납니다. 창업자는 팀원 이메일을 입력하여 초대 링크 전송을 실행하고, 초대받은 팀원은 링크를 클릭해 회원가입 및 해당 스타트업으로 자동 합류합니다.


온보딩 튜토리얼: 최초 로그인한 사용자에게 튜토리얼 모달 또는 안내 툴팁이 표시되어, 대시보드, 과제, 업데이트 등 핵심 메뉴 위치와 사용법을 간략히 설명합니다. 사용자는 “다음”, “건너뛰기” 등을 통해 튜토리얼을 진행하거나 종료할 수 있습니다.


첫 과제/업데이트 작성 권장: 온보딩 마지막에 “첫 번째 과제를 추가해보세요” 혹은 “투자자에게 보낼 첫 업데이트를 작성해보세요”와 같은 권장 액션이 표시되고, 클릭 시 해당 기능 페이지로 이동합니다.


2. 투자자 접근 요청 및 승인 흐름:
투자자의 스타트업 탐색: 투자자 사용자는 로그인 후 스타트업 목록/검색 페이지에서 관심 기업을 찾습니다. 공개 정보(스타트업 이름, 업종, 한 줄 소개 등)를 훑어보고 특정 스타트업 상세페이지로 진입합니다.


접근 권한 요청: 상세페이지에서 투자자는 “접근 요청” 버튼을 클릭합니다. 확인 다이얼로그에서 해당 스타트업의 기밀정보 접근에 대한 유의사항 및 (있다면 NDA 조항) 동의 체크박스를 확인한 뒤 요청을 확정합니다.


창업자 측 알림: 스타트업 관리자는 자신의 알림센터에서 투자자 X의 접근 요청 알림을 받습니다. 알림을 클릭하면 권한 승인 관리 페이지로 이동하여, 요청자 프로필(소속 VC, 경력 등)과 메시지(투자자가 간단한 인사말이나 요청 사유를 입력한 경우)를 검토합니다.


승인/거부 처리: 관리자는 승인 시 권한 수준 선택(예: 데이터룸 포함 전체권한 또는 일부 대시보드만 허용)을 하고 “승인” 버튼을 누릅니다. 시스템은 InvestorAccess 레코드를 업데이트하여 해당 투자자에게 열람 권한 부여, 그리고 양측에게 이메일로 승인 통보를 합니다. 거부 시 투자자에게 정중한 거절 통보가 전송됩니다.


투자자 열람: 권한이 승인되면 투자자는 자신의 투자자 대시보드에 해당 스타트업이 추가되고 “열람하기”를 눌러 스타트업의 상세 데이터를 볼 수 있습니다. 이제 데이터룸 문서 다운로드, 업데이트 히스토리 열람 등이 가능합니다. UI 상에는 해당 스타트업을 “액세스 가능“으로 표시하고, 필요하면 “연락하기” 등의 추가 액션(예: 이메일 문의 링크)을 제공합니다.


권한 철회: 만약 창업자가 권한을 철회하고자 할 경우, 권한 관리 페이지에서 해당 투자자를 선택해 “접근 철회“를 수행합니다. 그러면 투자자의 목록에서 해당 스타트업이 사라지고 향후 데이터에 접근할 수 없게 됩니다. 이 또한 시스템에서 투자자에게 알림으로 전달됩니다.


3. 과제 생성 및 완료 흐름:
과제 생성: 팀원이 프로젝트 보드 화면에서 “새 과제 만들기” 버튼을 클릭합니다. 나타나는 폼에서 과제 제목, 상세설명, 담당자, 마감일 등을 입력하고 저장하면, 보드의 “해야 할 일” 칼럼에 새로운 카드가 생성됩니다. 동시에 담당자에게 과제 할당 알림이 전송됩니다.


과제 진행 업데이트: 담당자는 과제를 시작할 때 카드의 상태를 “진행 중”으로 드래그하거나 편집 창에서 상태를 변경합니다. 변경 즉시 모든 팀원에게 실시간 갱신되며, 상태 변경 내역이 기록됩니다. 필요 시 진행 상황을 코멘트로 남길 수 있고, 관련 파일을 첨부해 공유합니다.


과제 완료: 과제가 완료되면 담당자 또는 관리자가 해당 카드를 “완료됨” 칼럼으로 이동합니다. 시스템은 완료 시각을 기록하고, 성과 지표(예: 이번 주 완료된 과제 수)에 반영합니다. 완료 알림이 팀에 공유되고, 연관된 다른 모듈(예: 동일 프로젝트의 타 과제)에 연결된 경우 진행률 갱신 등이 이뤄집니다.


회고 및 자동화: 과제가 반복 작업으로 지정되어 있다면 완료 시 자동으로 다음 주기 작업 생성 여부를 묻습니다. 사용자가 확인하면 새로운 과제가 미래 날짜로 생성됩니다. 또한 완료된 과제는 아카이브되어 대시보드의 성과 요약에 집계되고, AI 어시스턴트는 완료 과제들을 분석해 “주요 완료 업무” 등을 요약해주기도 합니다.


4. 투자자 업데이트 발행 흐름:
업데이트 작성: 창업자는 투자자 업데이트 메뉴에서 “새 업데이트 작성” 버튼을 클릭합니다. 월간 업데이트 템플릿이 로드되며, 전월 대비 주요 지표 증감, 주요 성과, 다음 목표 등의 구성을 채울 수 있습니다. AI 어시스턴트 버튼을 눌러 “지난달 성과 요약 작성”을 요청하면, 입력된 지표를 분석해 요약 문단을 자동 생성해줍니다.


미리보기 및 발행: 작성 완료 후 “미리보기”를 통해 투자자가 볼 화면을 확인합니다. 문제가 없으면 “투자자에게 발행” 버튼을 클릭합니다. 시스템은 업데이트 내용을 저장하고, 관련 투자자들에게 알림 및 이메일을 발송합니다. 이때 이메일에는 업데이트 요약과 링크가 포함됩니다.


투자자 열람: 투자자는 알림/이메일의 링크를 통해 플랫폼에서 업데이트 상세 내용을 확인합니다. 댓글 기능이 활성화된 경우, 투자자는 질문이나 피드백을 댓글로 남길 수 있고, 창업팀은 이에 답변할 수 있습니다 (필요에 따라 댓글 기능은 on/off 가능).


성과 추적: 스타트업 프로필의 “업데이트 히스토리”에 방금 발행한 업데이트가 추가됩니다. 관리자는 몇 명의 투자자가 열람했는지, 평균 열람 시간 등의 통계를 확인하여 투자자 관심도를 파악합니다. 또한 AI는 각 업데이트 내용을 분석하여 감정/반응 요약(예: “투자자들이 긍정적으로 받아들였을 주요 성과: XYZ”)을 관리자에게 제공해 이후 커뮤니케이션에 참고하도록 합니다.


5. 스타트업–VC 매칭 및 추천 흐름:
매칭 정보 입력: 창업자는 자신의 스타트업 프로필에 투자 유치 희망 사항을 입력합니다 (필요 투자금, 희망 투자 단계, 우대 분야 등). 투자자도 프로필에 선호 투자 조건(관심 산업, 투자 단계, 평균 투자 금액 범위)을 설정합니다.


자동 추천: 시스템은 일정 주기(예: 매주)로 백엔드에서 매칭 작업 배치를 실행하거나, 사용자가 매칭 페이지를 열 때마다 실시간 추천을 수행합니다. 스타트업과 투자자 각각에 대해 조건 매칭 알고리즘이 실행되어, 서로의 조건에 가장 부합하는 상위 N명을 선정합니다.


추천 목록 열람 (스타트업 측): 창업자는 “추천 투자자” 페이지에서 시스템이 제안한 투자자 리스트를 확인합니다. 각 투자자 카드에는 적합도 점수 또는 “매칭 이유” (예: “귀사 산업에 최근 투자 이력이 있습니다”) 등이 표시됩니다. 창업자는 리스트를 검토하고, 마음에 드는 투자자에게 프로필 공유 요청을 보낼 수 있는 UI를 통해 곧바로 접근 요청을 할 수 있습니다.


추천 목록 열람 (투자자 측): 투자자도 “추천 스타트업” 섹션에서 관심 가질 만한 스타트업 목록과 매칭 근거(예: “귀하가 관심 표명한 분야와 일치”)를 봅니다. 투자자는 스타트업 상세 페이지를 열어보고, 원할 경우 접근 요청 또는 미팅 요청을 보낼 수 있습니다.


피드백 루프: 사용자가 추천 결과에 대해 “관심 없음” 표시를 하거나, 실제로 연결(매칭)된 경우 등의 피드백 데이터가 축적됩니다. 향후 매칭 알고리즘은 이러한 피드백을 반영하여 추천 정확도를 개선합니다. 예를 들어 투자자가 계속 특정 분야 스타트업을 건너뛰면 그 분야 점수를 하향 조정합니다.


매칭 이후:* 추천을 통해 연결된 스타트업과 투자자는 이후 권한 승인 흐름이나 플랫폼 내 메시징을 통해 직접 교류를 이어갑니다. 매칭 자체는 추천/소개에 해당하며, 실질적인 투자 유치 프로세스는 오프라인에서 진행되겠지만, 추후 투자 확정 시 플랫폼 내에서 “투자 성사” 표시를 할 수 있는 기능으로 데이터베이스에 반영하여 향후 추천 알고리즘에 활용합니다.


이상의 UX 흐름도는 각 기능별 **사용자 여정(user journey)**를 나타내며, 화면 간 전환과 사용자 입력, 시스템 처리 결과를 명확히 기술합니다. 실제 구현 시에는 이 흐름을 참고하여 페이지 전환, API 호출, 예외 처리 등을 설계합니다.
5. UI 와이어프레임 설명 (UI Wireframe Notes)
주요 화면의 UI 구성을 와이어프레임 수준에서 설명합니다. 각 화면에는 핵심 컴포넌트와 사용자 인터랙션 요소가 표시되며, 일관된 디자인 시스템에 따라 구성됩니다.
메인 대시보드 (스타트업 사용자용): 화면 상단에는 헤더 내비게이션 바(로고, 메뉴, 알림 아이콘, 사용자 프로필 메뉴)가 위치합니다. 메인 콘텐츠 영역은 여러 위젯 카드로 구성되는데, 좌측 상단에는 “요약 KPI” 카드(예: 월 매출, 신규 고객 수 등 그래프), 그 옆에는 “진행 중인 과제” 리스트, 하단에는 “최근 투자자 업데이트 현황” 카드와 “팀 알림/멘션” 카드가 나열됩니다. 각 위젯에는 관련 데이터의 하이라이트와 간략 액션 버튼(예: 과제 위젯의 ‘자세히’ 버튼)이 포함됩니다. 디자인은 두 개의 컬럼 레이아웃으로, 화면 크기에 따라 반응형으로 재배치됩니다.


프로젝트/과제 관리 보드: Kanban 스타일 보드 UI로, 상단에 프로젝트 이름과 필터 옵션(담당자, 태그, 마감일)이 있습니다. 메인 영역에는 3~4개의 칼럼(“할 일”, “진행 중”, “검토 중”, “완료”)이 스크롤 가능한 가로 레이아웃으로 펼쳐져 있습니다. 각 칼럼에는 해당 상태의 과제 카드들이 세로로 나열되며, 카드에는 제목, 담당자 아바타, 마감일이 표시됩니다. 카드 드래그 앤 드롭이 가능하여 상태 변경을 직관적으로 할 수 있고, 카드를 클릭하면 오른쪽에 사이드바 상세 패널이 열려서 설명, 첨부파일, 댓글 등을 볼 수 있습니다. 보드 상단 또는 각 칼럼 하단에는 “+ 새 과제” 버튼이 배치되어 있어 새 과제를 추가하는 입력 폼을 모달로 띄웁니다.


스타트업 프로필 페이지: 좌측 상단에 스타트업 로고와 이름, 단계(뱃지 형태)가 표시되고, 우측 상단에 편집 버튼(팀원에게만 보임)과 투자자 권한 상태 표시가 있습니다. 페이지는 탭으로 구분되어 “개요”, “지표”, “데이터룸”, “업데이트” 등이 있습니다.


개요 탭: 회사 소개 글, 팀 멤버 사진과 직함 리스트, 제품 스크린샷 등이 배치됩니다.


지표 탭: 주요 지표들을 시계열 그래프로 보여주는 위젯 (예: 월별 매출 그래프, 사용자 증가 차트)와 표 형식 데이터가 있습니다.


데이터룸 탭: 업로드된 파일 리스트(문서명, 유형, 업로드일, 다운로드 버튼)가 표로 나타나며, 폴더별 정리 또는 카테고리 필터 기능이 있습니다. 투자자는 여기서 파일명을 클릭하면 권한 여부를 체크한 뒤 문서를 미리보기하거나 다운로드할 수 있습니다.


업데이트 탭: 과거 투자자 업데이트 글 목록이 카드 형태로 역순 정렬되어 있고, 각 카드에는 제목, 날짜, 요약 일부가 표시됩니다. 클릭하면 해당 업데이트의 상세 페이지(블로그 글 형태)가 열립니다.


투자자 대시보드 (투자자용): 스타트업용 대시보드와는 구성 요소가 다릅니다. 상단에는 투자자 프로필 요약(예: 소속 펀드, 직함, 관심 분야 태그)이 있고, 메인에는 포트폴리오 섹션과 추천 섹션 두 개로 나뉩니다. 포트폴리오 섹션에는 현재 접근 권한이 있는 스타트업들의 카드 리스트가 보여지며, 각 카드에는 스타트업 이름과 최신 업데이트 한 줄 요약, ‘자세히’ 버튼이 있습니다. 추천 섹션에는 알고리즘이 추천한 스타트업 카드들이 있고, ‘관심 없음’ 또는 ‘자세히 보기’ 액션이 가능합니다. 페이지 우측에는 전체 플랫폼에서 온 최근 업데이트 피드 (권한 있는 스타트업들의 최신 업데이트 제목과 날짜 목록)가 있어, 한눈에 업데이트 현황을 파악할 수 있습니다.


로그인 & 회원가입 페이지: 심플한 중앙 정렬 폼 UI입니다. 로고와 서비스명을 상단에 배치하고, 이메일/비밀번호 입력 필드, 로그인 버튼이 있습니다. 회원가입 페이지에서는 추가로 역할 선택(스타트업/투자자) 옵션과 약관 동의 체크박스 등이 포함됩니다. 디자인은 미니멀하고 깔끔하게, 배경에 옅은 브랜드 패턴이나 추상 일러스트를 배치하여 전문적인 인상을 줍니다. 에러 발생 시 필드 하단에 작은 빨간 글씨로 메시지를 표시하고, 성공 시 리다이렉트 피드백을 짧게 제공합니다.


알림 센터 드롭다운: 모든 페이지 헤더의 벨 아이콘을 클릭하면 드롭다운 패널이 나타나 최근 알림 5~7개를 보여줍니다. 각 알림 항목은 아이콘, 한줄 내용 (“OO 투자자가 열람 요청을 보냈습니다”, “마감 임박: X 과제”)과 시간을 표시하며, 클릭하면 해당 관련 화면으로 이동합니다. 하단에 “모든 알림 보기” 링크가 있어 알림 목록 페이지로 이동 가능합니다.


AI 어시스턴트 챗봇 창: 화면 우측 하단에 말풍선 아이콘으로 표시된 챗봇 위젯이 있습니다. 클릭 시 400px 정도 너비의 채팅 패널이 떠오르며, 상단에 “Glowus Assistant” 제목과 최소화/닫기 버튼, 본문에는 대화 기록과 입력창이 있습니다. 사용자가 질문을 입력하고 보내기를 누르면 챗봇이 타이핑 인디케이터를 잠시 표시한 후 답변 풍선이 나타납니다. 답변에는 출처 링크(예: “데이터룸 매뉴얼 문서”)나 버튼(예: “관련 과제 생성”)이 포함될 수 있습니다. 사용자는 채팅에서 제공된 버튼을 눌러 바로 해당 기능 페이지로 이동하거나, 추가 질문을 이어갈 수 있습니다. 챗봇 창은 다른 UI를 가리지 않도록 떠있는 레이어로 구현되고, 필요 시 드래그로 위치 이동도 가능합니다.


이상의 UI 설명은 와이어프레임 수준에서 화면 배치와 기능 요소를 설명한 것입니다. 실제 디자인 단계에서는 각 컴포넌트의 시각적 디테일(컬러, 폰트, 아이콘)을 디자인 시스템 가이드에 따라 적용하고, 반응형에 따른 모바일 레이아웃도 추가로 설계할 예정입니다. 여기서는 데스크톱 웹 기준의 구조를 중점으로 기술합니다.
6. 디자인 시스템 가이드 (Design System Guide)
스타트업쇼의 디자인 시스템은 일관된 브랜드 아이덴티티와 UX 일관성을 확보하기 위한 규칙과 컴포넌트 세트입니다 . 실무 활용을 위해 디자이너와 개발자가 모두 참고할 수 있도록 아래와 같은 항목들로 구성됩니다:
컬러 (Color Palette): 브랜드 메인 컬러는 스타트업의 성장과 신뢰를 상징하는 블루 (#3B82F6, 예시)를 사용합니다. 보조 색상은 성공/알림용 그린(#10B981), 경고/오류용 레드(#EF4444), 강조용 옐로(#F59E0B) 등을 지정합니다. UI 구성에 사용하는 중립색(Grayscale)은 다크/라이트 모드에서 모두 가독성을 보장하도록 10단계의 그레이 팔레트(예: #111→#fafafa)를 정의합니다 . 색상 사용 가이드: 주요 액션 버튼/강조 텍스트에는 메인 블루를 사용하고, 삭제 버튼 등 파괴적 행위에는 레드를 적용하며, 배경과 테두리에는 중립색 계열을 사용합니다.


타이포그래피 (Typography): 국문/영문을 모두 가독성 있게 표현하기 위해 Sans-serif 계열 웹폰트를 사용합니다 (예: Noto Sans KR 또는 Pretendard). 글자 크기는 Heading1~6, Body, Caption 등 스타일을 정의하며, 예를 들어 Heading1=24px Bold, Heading2=20px Semibold, Body=14px Regular, Caption=12px Regular로 지정합니다. **한글 본문 특성상 충분한 line-height(예: 1.6)**를 적용하여 가독성을 높입니다 . 또한 영어와 혼용 시 어색함이 없도록, 폰트 fallback 체계를 지정하고 자간/장평을 미세 조정합니다. 일관성을 위해 디자인 시스템에 **텍스트 스타일 가이드(피그마 Text Style)**로 저장되어 개발 시 동일한 CSS를 적용합니다.


아이콘 (Iconography): 인터페이스에 쓰이는 아이콘은 Feather Icons와 같이 가볍고 선명한 스타일의 라인 아이콘 세트를 사용합니다. 아이콘 크기는 주로 16px 또는 24px (4px 배수 원칙)로 사용하며, Stroke 두께 2px의 통일된 스타일을 갖습니다 . 아이콘은 의미에 따라 색상을 메인 컬러나 중립색으로 적용하되, 사용자 조작이 필요한 아이콘(예: 버튼 내부의 + 아이콘)은 메인 컬러로 강조합니다. 모든 아이콘은 손쉬운 사용을 위해 스프라이트 혹은 SVG 심볼로 관리되어, 개발자는 <Icon name="edit" />처럼 쉽게 사용할 수 있습니다.


레이아웃 & 그리드: 반응형 디자인을 고려해 12컬럼 그리드 시스템을 채택합니다. 컨텐츠 최대 폭은 데스크톱에서 1200px, 태블릿 720px, 모바일 360px 등의 브레이크포인트에 맞춰 조정됩니다. 컴포넌트 간 여백은 4px 단위의 Spacing Scale로 정의되어 (4, 8, 12, 16, 24, 32...px), 제목과 본문 사이 마진, 카드 내부 패딩 등 모든 간격에 일관적으로 적용합니다. 시각적인 일관성을 위해 아이콘과 텍스트 baseline 정렬, 버튼 높이(예: 40px) 및 라운딩(예: 4px radius) 등도 규격화합니다.


컴포넌트 라이브러리: 디자인 시스템은 핵심 UI 컴포넌트들을 정의합니다 . 여기에는 버튼(Button), 입력 폼(Input, Select), 모달 다이얼로그(Modal), 내비게이션 바(Navbar), 카드(Card), 테이블(Table) 등이 포함됩니다. 각 컴포넌트는 상태 변화에 따른 모습(예: 버튼의 기본/호버/비활성화/눌림)에 대한 스타일을 모두 규정합니다.


버튼: Primary, Secondary, Tertiary 3가지 유형. Primary는 메인 컬러 배경에 흰색 글씨, Secondary는 테두리만 있고 투명 배경, Tertiary는 텍스트만 있는 링크 스타일. 각 버튼은 :hover, :active, :disabled 상태에서 색상/커서 변경 사항을 명시합니다.


폼 요소: Input, Textarea 등은 라운드 모서리와 1px 중립색 테두리를 가지고, 포커스 시 메인 컬러 테두리와 상승된 그림자를 적용합니다. Placeholder의 스타일과 폰트 크기도 본문 스타일과 통일합니다. 에러 발생 시 테두리를 Red로, 하단에 에러 메시지 텍스트(작은 빨간색 폰트) 표기 규칙을 둡니다.


네비게이션: 사이드바 메뉴와 상단바 등을 정의합니다. 사이드 메뉴 아이템은 선택된 경우 배경 강조(연한 메인컬러 하이라이트)되고 앞에 파란 인디케이터 바를 표기합니다. 상단바는 그림자 효과와 1px 보더로 구분되며, 반응형으로 아이템 숨김 처리 규칙을 가집니다.


카드: 통계 위젯이나 리스트 항목 등에 쓰이는 카드 컴포넌트는 기본적으로 흰색 배경, 8px 라운드, 그림자(약한 depth)를 갖고, 내용 패딩은 16px입니다. 카드 헤더, 바디, 푸터의 섹션 구분을 위한 spacing과 타이포 hierarchy를 정의하고, Overflow 시 스크롤 처리 등을 명시합니다.


디자인 원칙: 스타트업쇼 디자인은 신뢰성과 모던함을 핵심으로 합니다. 따라서 불필요한 장식보다는 미니멀한 스타일을 취하고, 정보 우선 순위를 색상과 타이포그래피로 명확히 구분합니다. 또한 접근성(Accessibility) 기준을 준수하여 콘트라스트 비율(최소 4.5:1)을 확보하고, 시각적 외에도 툴팁/레이블로 정보를 제공해 사용자가 시스템을 쉽게 이해하도록 합니다. 반응형 디자인 원칙 하에 모바일에서는 요소를 한 열로 쌓고 터치 영역을 충분히 크게 유지하는 등, 다양한 디바이스에서 일관된 사용자 경험을 보장합니다.


디자인 시스템 문서는 위의 항목별 상세 규칙과 함께, 실제 예시 스크린샷과 컴포넌트별 코드 스니펫(CSS 클래스) 등을 포함합니다. 이를 통해 디자이너는 시안을 제작하고 개발자는 재사용 가능한 UI 컴포넌트를 구현할 때 참고하게 됩니다. 디자인 시스템은 프로젝트 진행 중 지속적으로 업데이트/관리되며, 새로운 컴포넌트 등장 시 가이드에 추가하여 디자인 자산의 일원화를 유지합니다.
7. 기술 아키텍처 문서 (Architecture Document)
기술 아키텍처 문서는 스타트업쇼의 시스템 구성 요소와 상호 작용을 상세히 기술합니다. 위 그림은 전체 아키텍처의 개략적인 구성도이며, 주요 요소는 다음과 같습니다:
클라이언트 (웹 UI): React(Typescript) 기반 SPA로 구현되며, Next.js 등의 프레임워크를 사용해 SSR/CSR 조합으로 SEO와 초기 로딩 속도를 개선할 수 있습니다. 클라이언트는 컴포넌트 기반 구조로 페이지별 모듈을 구성하고, 상태 관리는 Redux 또는 React Query를 통해 서버 상태를 효율적으로 캐싱합니다. API 호출은 Axios 등을 통해 백엔드 REST API와 통신하며, JWT 토큰을 HTTP Authorization 헤더에 포함시켜 요청마다 인증을 수행합니다. 또한 PWA 지원을 통해 모바일 웹 사용성도 강화합니다.


백엔드 API 서버: Node.js + Express (또는 NestJS)를 사용한 API 서버가 응용 로직의 중심입니다. 이 서버는 Clean Architecture 원칙에 따라 Controller → Service → Repository (DAO) 계층으로 구성되어, 유지보수성과 테스트 용이성을 높였습니다. 주요 기능:


인증/인가: JWT 기반 인증을 수행하며, 미들웨어에서 토큰을 검증하고 req.user 객체에 사용자 정보를 로드합니다. Role 기반 권한 검증(RBAC)을 통해 각 엔드포인트에서 권한이 부족하면 403 오류를 반환합니다. 예를 들어, 투자자가 권한 없는 스타트업의 리소스를 요청하면 403 Forbidden 처리합니다.


비즈니스 로직: Service 계층에서 과제 생성, 업데이트 발행 등 각각의 시나리오별 도메인 로직을 수행합니다. 예를 들어, 투자자 접근 승인 로직은 (a) InvestorAccess 테이블 업데이트, (b) 알림 생성, (c) 이메일 발송 트리거를 순차적으로 실행합니다. 이러한 로직은 트랜잭션 단위로 묶여 원자성을 유지합니다.


데이터베이스 연동: Repository 계층에서 ORM(예: TypeORM 또는 Prisma)을 통해 PostgreSQL DB에 접근합니다. 복잡한 조인은 View 또는 Stored Procedure를 활용하지 않고 ORM 레벨에서 해결하며, 필요한 경우 튜닝을 위해 원시 쿼리를 사용합니다. Redis와 같은 인메모리 캐시를 두어 자주 조회되는 공통 데이터(예: 산업 분야 리스트)는 캐싱합니다.


파일 스토리지: 데이터룸에 업로드되는 파일은 서버 디스크가 아닌 AWS S3 버켓에 저장됩니다. API 서버는 파일 업로드 요청을 받아 사전 서명 URL을 발급하고 이를 통해 클라이언트가 S3에 직접 업로드하도록 합니다. 다운로드 시에도 권한 확인 후 S3 객체의 pre-signed URL을 생성하여 브라우저에 전달하는 간접 접근 방식을 취해, 보안과 성능을 모두 확보합니다.


통합 및 이벤트: API 서버는 내부적으로 이벤트 큐(Pub/Sub) 또는 간단한 이벤트 에미터를 사용하여, 특정 액션 발생 시 후속 처리를 비동기로 수행합니다. 예를 들어, “업데이트 발행” API 호출이 완료되면 UpdatePublished 이벤트를 발생시키고, 이를 수신하는 리스너가 이메일 전송 작업을 비동기로 처리합니다. 이러한 구조로 메인 플로우의 응답 지연을 최소화합니다.


AI 엔진/에이전트 모듈: 백엔드와 별도로 AI 관련 연산을 전담하는 모듈입니다. 경우에 따라 이 모듈은 Python 기반의 마이크로서비스(FastAPI 등)로 구현하여, AI 생태계의 풍부한 라이브러리(scikit-learn, Transformers 등)를 활용할 수 있습니다. 그러나 현재 설계에서는 Node.js 서버 내에서 필요한 경우 Python 스크립트를 호출하거나, 또는 LangChain JS와 같이 Node 환경에서 동작 가능한 라이브러리를 활용하는 방안을 검토 중입니다. AI 모듈의 주요 역할:


임베딩 및 벡터DB 관리: 문서나 텍스트를 임베딩 벡터로 변환하고, 이를 Pinecone 등의 Vector DB에 저장/질의합니다. OpenAI Embedding API (text-embedding-ada-002 모델 등)를 사용하여 각 문서를 벡터화하며, 스타트업별로 고유한 벡터 index or namespace를 유지합니다. 벡터DB 인터페이스는 API 서버에서 직접 호출하거나, 성능을 위해 AI 모듈이 검색 API endpoint를 노출시켜 제공할 수 있습니다.


LLM 프롬프트 처리: 사용자의 자연어 질문이 들어오면, AI 모듈은 우선 벡터 검색으로 관련 정보를 조회합니다. 이후 프롬프트 템플릿(Prompt Library에서 정의)을 적용하여 LLM에게 질의합니다. OpenAI GPT-4 모델을 기본으로 사용하며, 응답에서 발생할 수 있는 환각을 줄이고자 시스템 메시지에 제한 정책(예: “출처로 제시된 정보만 기반으로 답변하세요”)을 포함합니다. LLM API 호출 후 결과를 받아, 필요한 후처리(출처 링크 주입 등)를 수행하여 반환합니다.


에이전트 도구 사용: AI 에이전트가 복잡한 요청을 처리하기 위해 여러 단계의 액션을 수행할 수 있습니다. 예를 들어 사용자가 “우리 회사 이번달 매출증가율 계산해서 그에 따라 해야 할 일 등록해줘”라고 요청하면, 에이전트는 (a) DB에서 매출 수치를 조회하거나 최근 업데이트에서 값을 추출하고, (b) 계산을 수행한 후, (c) 과제 생성 API를 호출하는 순차적 작업을 할 수 있습니다. 이를 위해 에이전트는 Tool 개념으로 내부 API들을 함수로 노출받아, LLM의 Function calling 기능으로 호출합니다.


구현 측면에서, LangChain의 Reactive Agent(React) 체계를 활용하여 tools = ["database_query", "create_task_api", "vector_search"]와 같은 도구를 정의하고, LLM이 프롬프트를 통해 이 도구들을 호출하게 합니다.


예를 들어, database_query 도구는 내부적으로 SQL 쿼리를 실행하여 응답을 주고, LLM은 그 결과를 받아 reasoning을 이어갑니다. 마지막으로 create_task_api 도구를 호출하여 실제 과제를 생성하고, 사용자에게 “매출 증가율이 X%로 확인되어, 관련 후속 과제를 생성했습니다.“라는 답변을 제공합니다.


안전성과 승인을 위한 장치: 에이전트가 자동으로 액션을 수행하는 경우 사전 정의된 안전 규칙이 적용됩니다. 중요하거나 파괴적인 작업(예: 데이터 삭제)은 에이전트가 시도하더라도 인간 승인을 요구하도록 설계합니다. 이러한 안전장치는 LLM의 응답을 분석하거나, 특정 API endpoints에 requires_confirmation 플래그를 두어, 실행 전에 담당자에게 확인 요청 알림을 보내는 형태로 구현됩니다.


데이터베이스 (RDBMS): PostgreSQL을 사용하며, AWS RDS 상에 구성되어 일일 백업, Multi-AZ 등 고가용성 옵션을 켭니다. DB 스키마는 데이터베이스 ERD & 스키마에 상세히 있으며, 주요 테이블인 User, Startup, Task, Update 등은 각종 인덱싱과 제약 조건(FK 제약, Unique 등)을 설정하여 무결성과 조회 성능을 보장합니다. 특히 InvestorAccess 테이블에는 (Startup, Investor) 페어에 Unique 인덱스를 걸어 중복 요청을 방지하고, 상태필드에 인덱스를 걸어 승인 대기중인 레코드 쿼리를 최적화합니다.


Vector Database: Pinecone 또는 ChromaDB 등을 사용하여 임베딩 벡터를 저장합니다. 각 벡터는 해당 정보 조각의 메타데이터(출처 문서 ID, 연관 스타트업 ID 등)를 포함하므로, 질의시 필터링(예: 특정 스타트업의 문서만 검색)이 가능합니다. 백엔드에서는 similarity_search(query_vector, top_k, filter=...) 메소드를 호출해 가장 유사한 k개 벡터와 원문을 가져와 LLM 프롬프트에 삽입합니다. Vector DB 서비스와 통신은 네트워크 I/O이므로 성능 영향을 최소화하기 위해 결과를 캐싱하거나, 동기 질의 대신 비동기로 전환하는 등의 최적화를 적용합니다.


캐시 & 메시징: Redis를 도입하여 세션 캐시(만약 JWT 대신 서버세션을 쓴다면), 빈번히 읽는 설정값(예: 산업 카테고리 목록) 등을 캐싱합니다. 또한 추후 메시지 브로커(예: RabbitMQ, AWS SQS)를 도입하여 마이크로서비스 간 통신이나 작업 큐(예: 이메일 대량 발송)를 처리할 예정입니다.


3rd-party API 연동: 다양한 외부 API와의 연동이 존재합니다. 이메일 발송은 SendGrid API를 사용하고, OAuth 로그인을 위해 Google, LinkedIn 인증 API를 붙일 수 있습니다. 또한 투자자 친화 기능으로 Crunchbase 등 외부 스타트업 데이터베이스 API를 조회하여 스타트업 정보를 자동 입력하거나, 반대로 투자자에 대한 공개 데이터를 참고할 수 있습니다. 이러한 외부 통신은 별도 서비스 모듈로 분리하여 관리하며, 실패 시 재시도 로직, 속도 제한(rate limit) 대처를 구현합니다.


아키텍처 관점 주요 고려사항:
확장성: 모놀리식으로 시작하더라도 도메인 경계를 명확히 나눠 모듈화하였기 때문에, 특정 기능이 부하가 크면 해당 모듈만 분리하여 별도 서비스로 확장 가능합니다. (예: AI 모듈의 부하가 증가하면 Python 서비스로 독립 배포)


내결함성: 각 구성 요소에 장애가 발생해도 전체 서비스가 다운되지 않도록 격리되어 있습니다. 예를 들어 AI 모듈이 응답하지 않으면 핵심 기능 외에 AI 기능만 제한적으로 작동하고, 백엔드는 타임아웃 후 degrade된 응답(“현재 AI 기능을 사용할 수 없습니다”)을 제공합니다.


보안: 클라이언트-서버 간 모든 통신은 HTTPS/TLS로 암호화됩니다. 서버 내부적으로는 중요한 환경변수(API 키 등)를 AWS Secrets Manager 등에서 주입 받아 관리하고, 데이터베이스 접근 계정도 최소 권한으로 설정합니다. 또한 XSS/SQLi 대비 입력 validation, CSP 설정 등 웹 보안 설정을 글로벌하게 적용합니다.


8. 데이터베이스 ERD & 스키마 (DB 구조 및 스키마)
위 ERD 다이어그램은 스타트업쇼 데이터베이스의 주요 개체와 관계를 나타냅니다. 이를 토대로 각 테이블과 스키마를 설명합니다:
User 테이블: 플랫폼의 모든 사용자 정보를 관리합니다. 필드:


UserID (PK, UUID) - 사용자 고유 식별자.


Name (String) - 사용자 이름.


Email (String, Unique) - 로그인 및 식별용 이메일 주소.


PasswordHash (String) - 비밀번호 해시(BCrypt 등으로 암호화 저장).


Role (Enum) - 사용자 역할 유형: FOUNDER (창업자/스타트업팀), INVESTOR (투자자), ADMIN (관리자).


Company (nullable String) - 투자자인 경우 소속 VC명 등 (스타트업 팀원의 경우 자신의 스타트업 Company Name과 중복될 수 있어 분리).


CreatedAt, UpdatedAt (Timestamp) - 레코드 생성 및 갱신 시각.


User 테이블에는 Email에 유니크 인덱스가 설정되어 있으며, Role에 따라 연관된 다른 테이블과 관계를 가집니다. (예: 스타트업팀원은 TeamMember 테이블과 연결, 투자자는 InvestorAccess 통해 스타트업과 연결)


Startup 테이블: 스타트업(회사) 정보를 관리합니다. 필드:


StartupID (PK, UUID) - 스타트업 고유 식별자.


Name (String) - 회사명.


Industry (String) - 업종/분야 (태그 혹은 카테고리명).


Stage (Enum) - 회사 단계 (예: SEED, SERIES_A, B2C, B2B 등 자유정의 가능).


Description (Text) - 회사에 대한 소개/비전.


Website (String) - 웹사이트 URL.


CreatedBy (FK to User) - 프로필 생성자 (창업자 계정).


CreatedAt, UpdatedAt (Timestamp).


Startup과 User는 다대다 관계인데, 창업자는 TeamMember를 통해 연결됩니다. CreatedBy는 편의상 초기 생성자를 기록해 놓은 것이며, 실제 팀원 명단은 TeamMember 테이블에서 관리합니다.


TeamMember 테이블: 스타트업 <-> 사용자 간 팀 소속 관계를 나타냅니다. 필드:


StartupID (PK, FK→Startup) - 소속 회사.


UserID (PK, FK→User) - 팀원 사용자.


Role (Enum) - 팀 내 역할 (OWNER 창업자/대표, MEMBER 팀원 등).


JoinedAt (Timestamp) - 합류일.


한 User가 여러 스타트업 팀에 속할 수 있고(예: 연쇄창업 등), 한 스타트업에 여러 User가 속할 수 있으므로 복합 PK로 다대다를 풀었습니다. Owner는 각 스타트업당 한 명으로 제한하거나, Role 필드로 구분만 하고 논리적으로 처리할 수 있습니다. 이 테이블에 대한 조회가 빈번할 것으로 예상되므로 (특히 어떤 User의 모든 Startup 소속 등), UserID와 StartupID 각각에 인덱스를 추가하여 부분 조회를 최적화합니다.


InvestorAccess 테이블: 투자자 열람 권한 요청 및 상태를 관리합니다. 필드:


InvestorID (PK, FK→User) - 투자자 사용자 (User.Role = INVESTOR).


StartupID (PK, FK→Startup) - 접근 대상 스타트업.


Status (Enum) - 요청/권한 상태: PENDING(요청 대기), APPROVED(승인됨), REVOKED(철회됨), DENIED(거부됨).


RequestedAt (Timestamp) - 요청 시각.


DecidedAt (Timestamp, nullable) - 승인/거부 처리 시각.


ApprovedBy (FK→User, nullable) - 승인 처리한 스타트업 관리자.


InvestorAccess는 투자자와 스타트업 간 권한 부여 관계를 나타냅니다. 투자자가 접근 요청을 하면 새로운 레코드가 (Status=PENDING) 생성되고, 창업자 승인 시 Status를 APPROVED로 갱신합니다. PK를 InvestorID+StartupID 복합키로 설정하여 중복 요청을 방지합니다. (Unique 제약) 또한 상태별로 효율적 조회를 위해 Status 필드에 인덱스를 추가하였습니다 (예: 어떤 스타트업의 PENDING 요청 전체 조회).


Task 테이블: 스타트업 운영 과제/업무 항목을 나타냅니다. 필드:


TaskID (PK, UUID) - 과제 식별자.


StartupID (FK→Startup) - 해당 과제가 속한 스타트업.


Title (String) - 과제 제목.


Description (Text) - 상세 설명.


Status (String 또는 Enum) - 상태 (예: TODO, IN_PROGRESS, DONE 등).


Assignee (FK→User, nullable) - 담당자 (없을 수 있음).


DueDate (Date, nullable) - 마감기한.


CreatedAt, UpdatedAt (Timestamp).


한 스타트업에 다수 과제가 존재하며(Task.StartupID -> Startup 다대일 관계), Assignee는 해당 스타트업 팀원이어야 하므로 비즈니스 로직에서 검증합니다. 주요 인덱스: StartupID (스타트업별 과제 리스트 조회 시), Assignee (담당자별 조회 시). 또한 완료된 과제만 모아볼 때를 대비해 Status에도 인덱스를 고려할 수 있습니다. 과제 상태 변경은 주로 UI 보드에서 드래그앤드롭으로 일어나므로, 단일 레코드의 Update 트랜잭션으로 충분합니다.


Update 테이블: 투자자에게 공유되는 업데이트/보고서를 관리합니다. 필드:


UpdateID (PK, UUID) - 업데이트 식별자.


StartupID (FK→Startup) - 해당 업데이트의 회사.


Title (String) - 업데이트 제목 (예: “2023년 10월 업데이트”).


Content (Text) - 본문 내용 (마크다운 또는 HTML 저장).


CreatedAt (Timestamp) - 작성 시각.


Published (Boolean) - 투자자에게 발행되었는지 여부.


PublishedAt (Timestamp, nullable) - 발행 시각.


MetricsSnapshot (JSON, nullable) - 업데이트 당시의 주요 지표 스냅샷 (예: {“MRR”: 12000, “NewUsers”: 300}).


Update는 작성 후 임시 저장(발행 전 상태)될 수도 있고, 발행 완료되면 Published=true로 표시합니다. 발행 시점의 지표 등을 JSON으로 저장해두면, 시간이 지나 데이터베이스 값이 변해도 당시 수치를 유지할 수 있습니다. (필요 시 별도 UpdateMetric 테이블로 정규화도 가능하나 간편성을 위해 JSON 사용). 이 테이블에는 StartupID 인덱스, Published 인덱스를 두어, 투자자 화면에서 특정 스타트업의 발행된 업데이트 목록을 빠르게 조회합니다. 또한, Update에 연결된 투자자 열람 기록이 별도로 있을 수 있는데 (투자자가 업데이트를 열람했는지 여부), 현재 스키마에서는 다루지 않았지만 UpdateView 테이블을 만들어 InvestorID, UpdateID, ViewedAt 등을 기록할 수 있습니다.


Document 테이블 (추가 고려): 데이터룸에 업로드된 파일 정보를 관리할 수 있습니다. 필드:


DocumentID (PK, UUID), StartupID (FK), FileName, FileType, StoragePath (S3키 등), UploadedAt, UploadedBy (FK to User).


권한상 InvestorAccess가 APPROVED인 투자자만 해당 StartupID의 Document를 다운로드할 수 있으므로, 이를 검증합니다. Document 테이블은 현재 ERD 다이어그램에는 생략되었으나, 구현시 데이터룸 기능에 포함됩니다.


스키마 제약 및 규칙:
모든 FK 제약에는 ON DELETE CASCADE 또는 SET NULL 정책을 검토합니다. 예를 들어 스타트업이 삭제되면 관련 TeamMember, InvestorAccess, Task, Update를 모두 지우거나, 논리삭제 플래그를 사용할 것입니다. 일반적으로 실제 스타트업 삭제는 일어나지 않겠지만 (데이터 보존을 위해 비활성화 처리), 관계 설정은 해둡니다.


중요 필드 (Email, InvestorAccess 복합키 등)에 Unique 제약을 걸어 데이터 무결성을 확보합니다.


정규화 vs 성능 밸런스: 산업(Industry)같은 값은 Startup 테이블에 문자열로 저장했지만, 추후 정규화하여 Industry별 테이블을 둘 수도 있습니다. 초기엔 단순 구현을 택하고, 데이터량 증가나 기능 확장 시 리팩토링합니다.


감사 로그(Audit Log)를 위해 모든 주요 테이블에 CreatedAt/UpdatedAt외에 CreatedBy/UpdatedBy를 넣을 수도 있습니다. 현재 User, Startup 등 일부 필드에만 있고, Task, Update 등은 UpdatedBy는 생략했으나 필요 시 추가 가능합니다.


샤딩/파티셔닝 계획: 현 시점에서는 테이블 수가 크지 않으나, 장기적으로 업데이트나 과제 데이터가 매우 커질 경우를 대비해 파티셔닝을 고려합니다. 예를 들어 Update 테이블을 StartupID를 기준으로 파티션하면 특정 스타트업별 I/O를 분산시킬 수 있습니다. 또는 시간에 따라 월별 파티션으로 관리하여 오래된 데이터에 대한 관리(아카이빙)를 용이하게 할 수 있습니다.
데이터베이스 스키마는 위 설명대로 정규화와 성능 요구를 균형 있게 반영하였으며, 어플리케이션 로직에 맞춰 필요 인덱스와 제약을 설정하였습니다. 개발과정에서 마이그레이션 스크립트(예: Prisma migration 또는 Flyway)를 사용해 버전 관리를 하고, staging 환경에서 충분히 쿼리 플랜을 검토하여 튜닝할 것입니다.
9. API 명세서 (API Specification)
이 섹션에서는 스타트업쇼 백엔드의 REST API를 기능별로 명세합니다. 각 엔드포인트는 HTTP 메소드, 경로, 요청/응답 형태, 권한 요건 등을 정의합니다. (예시로 주요 API만 선별)
인증 & 사용자 API
메소드
경로
설명
POST
/api/auth/register
회원가입 API. 요청 바디에 name, email, password, role 등을 받고 새 User 생성. 이메일 중복시 409 오류. 성공 시 JWT 발급.
POST
/api/auth/login
로그인 API. email, password로 인증하여 JWT 토큰 발급. 잘못된 경우 401 Unauthorized.
GET
/api/users/me
현재 로그인한 사용자의 프로필 조회. JWT 필요. 본인 User 정보와 속한 스타트업 목록, 역할 등을 반환.

스타트업 & 팀 관리 API
메소드
경로
설명
POST
/api/startups
신규 스타트업 생성. Body에 회사명, 분야 등 포함. 해당 요청자는 자동으로 TeamMember에 OWNER로 추가. (AUTH: 회원 로그인 필요)
GET
/api/startups/{startupId}
스타트업 프로필 조회. 권한 있는 사용자만 상세 정보 반환. 투자자의 경우 공개 정보+승인된 데이터만 포함.
PATCH
/api/startups/{startupId}
스타트업 프로필 편집. (AUTH: 해당 스타트업 OWNER만)
POST
/api/startups/{startupId}/invite
팀원 초대. Body에 email, role 포함. 해당 이메일에 초대 링크 발송하거나 즉시 TeamMember 생성. (AUTH: OWNER만)
GET
/api/startups/{startupId}/team
해당 스타트업의 팀원 목록 조회. (AUTH: 팀원 이상)

과제 (Task) API
메소드
경로
설명
GET
/api/startups/{startupId}/tasks
특정 스타트업의 과제 목록 조회. 쿼리파라미터로 상태 필터 등 제공 (예: ?status=TODO). (AUTH: 팀원 이상)
POST
/api/startups/{startupId}/tasks
새 과제 생성. Body에 title, description, assignee, dueDate 등. (AUTH: 팀원 이상)
PATCH
/api/startups/{startupId}/tasks/{taskId}
과제 편집 (상태변경 포함). (AUTH: 해당 과제 담당자 또는 팀원 이상)
DELETE
/api/startups/{startupId}/tasks/{taskId}
과제 삭제. (AUTH: 과제 작성자 또는 관리자)
POST
/api/startups/{startupId}/tasks/{taskId}/comment
과제 댓글 추가. Body에 내용. (AUTH: 팀원 이상)

투자자 업데이트 (IR) API
메소드
경로
설명
GET
/api/startups/{startupId}/updates
스타트업의 발행된 투자자 업데이트 리스트 조회. (AUTH: 투자자 권한 승인 필요; 팀원은 자기 회사라면 초안 포함 조회 가능)
POST
/api/startups/{startupId}/updates
새 투자자 업데이트 작성 (초안 상태). (AUTH: 팀원 이상)
GET
/api/updates/{updateId}
특정 업데이트 상세 조회. 권한 요구는 위와 동일.
PATCH
/api/updates/{updateId}
업데이트 내용 수정 (발행 전 초안만). (AUTH: 작성자)
POST
/api/updates/{updateId}/publish
투자자에게 업데이트 발행. 상태를 Published로 변경하고 알림 처리 트리거. (AUTH: 팀원 이상)

투자자 권한 & 매칭 API
메소드
경로
설명
GET
/api/startups?search=키워드
공개 스타트업 검색. 쿼리 파라미터로 키워드, 산업, 단계 등. 공개 필드만 반환. (AUTH: 투자자도 사용 가능)
POST
/api/startups/{startupId}/request-access
투자자가 특정 스타트업 열람을 요청. (AUTH: 투자자)
GET
/api/startups/{startupId}/access-requests
해당 스타트업의 투자자 접근 요청 목록 조회. (AUTH: 스타트업팀 OWNER)
PUT
/api/startups/{startupId}/access-requests/{investorId}
요청 승인/거부 처리. Body에 승인 여부 및 메시지(optional). (AUTH: OWNER)
GET
/api/investors/recommendations
로그인 투자자에게 추천 스타트업 리스트 반환. (AUTH: 투자자)
GET
/api/startups/{startupId}/recommendations
특정 스타트업에 대한 추천 투자자 리스트. (AUTH: 스타트업팀)

AI 어시스턴트 API
메소드
경로
설명
POST
/api/ai/query
AI 어시스턴트 질의. Body에 question 포함. 해당 사용자의 맥락(소속 스타트업 등)에 맞게 답변을 생성. (AUTH: 로그인 필요)
POST
/api/ai/action
AI 에이전트 액션 요청. 사용자의 자연어 명령(command)을 받아, 필요한 경우 여러 내부 액션 수행 후 결과를 반환. (예: “다음주 회의 일정 잡아줘” -> 캘린더 API 호출) (AUTH: 로그인 필요, 베타 기능)

응답 형식 및 에러 처리: 모든 API 응답은 JSON 형식으로 반환됩니다. 정상 경우 각 API별 정의된 데이터 오브젝트 또는 작업 결과를 담고, 실패 시 error 객체를 포함하여 HTTP 상태코드에 맞는 메시지를 제공합니다. (예: 400 잘못된 요청, 401 인증실패, 403 권한없음, 404 자원없음, 500 서버오류 등). 또한 X-Request-ID 헤더를 지원하여 클라이언트가 요청 추적을 할 수 있도록 합니다.
보안 측면: JWT 토큰은 HttpOnly 쿠키 혹은 Authorization 헤더로 사용되며, CSRF 보호를 위해 쿠키 사용 시 이중 제출 쿠키 전략을 적용합니다. 중요한 수정/삭제 API는 서버 측 권한 체크를 이중으로 거치고, 투자자 권한이 필요한 API는 요청자 JWT의 userId와 InvestorAccess 테이블을 대조하여 권한이 없으면 403을 반환합니다.
레이트 리밋 및 QoS: 인증 관련 API(login 등)에는 IP당 레이트리밋(예: 5분간 5회)이 설정되고, AI API는 한 사용자당 분당 호출 제한을 둘 예정입니다. 이는 X-RateLimit 헤더 등을 통해 클라이언트에 피드백됩니다.
API 명세는 위 표에 요약된 것 외에도 세부 엔드포인트(예: 댓글 CRUD, 알림 읽음 처리, 관리자용 API 등)가 존재합니다. 전체 명세는 OpenAPI (Swagger) 문서로도 제공되어 개발과 테스트 시 참고하도록 합니다.
10. AI 프롬프트 라이브러리 (AI Prompt Library)
스타트업쇼에서는 다양한 AI 기능별로 최적화된 프롬프트 템플릿을 정의하여 일관되고 효과적인 AI 응답을 얻습니다. 프롬프트 라이브러리는 이러한 템플릿의 모음으로, 아래와 같이 기능별 대표 프롬프트와 사용 예시를 설명합니다:
업무 요약 프롬프트 (Task Summary Prompt):


용도: 지정된 기간의 완료된 과제들을 요약하고 주요 성과를 도출할 때 사용합니다. 예를 들어 주간 팀 회고 보고서 생성 시.


프롬프트 템플릿 예시:


주어진 완료 작업 리스트를 읽고, 이 주에 달성된 주요 목표와 성과를 두 문장으로 요약하세요:
{작업_목록}
- 요약:




설명: {작업_목록} 자리에는 완료된 과제들의 제목과 결과가 나열됩니다. 어시스턴트는 이를 기반으로 “이번 주에 마케팅 캠페인을 성공적으로 실행하여 예상 대비 120%의 리드 확보 성과를 달성했습니다.“와 같이 응답합니다.


투자자 업데이트 초안 프롬프트 (Investor Update Draft Prompt):


용도: 창업자가 투자자 업데이트를 작성할 때, 입력한 주요 지표와 내용을 바탕으로 매끄러운 초안을 생성합니다.


프롬프트 템플릿 예시:


아래 항목들을 포함하여 투자자 업데이트 초안을 작성해주세요.
1. 핵심 지표 변화: {지표_요약} 
2. 주요 진행 사항: {주요_성과} 
3. 차후 계획: {다음_계획}
위 내용을 바탕으로 3문단 정도의 전문적인 업데이트 내용을 한국어로 작성합니다.




설명: 프롬프트에는 창업자가 입력한 이번 달 지표 요약, 주요 성과 bullet, 다음 달 계획 bullet이 들어갑니다. 모델은 이를 토대로 서두/본론/결론 구조의 보고서 초안을 작성하며, 숫자와 성과를 자연스럽게 녹여냅니다. 작성 결과는 사용자가 수동으로 다듬기 쉽도록 포멀한 문체로 생성됩니다.


질의응답 프롬프트 (Q&A Prompt with Context):


용도: 투자자나 팀원이 스타트업 관련 질문을 하면, 벡터DB에서 맥락을 찾아 정확한 답을 제공하기 위해 사용합니다.


프롬프트 템플릿 예시:


[배경 지식]
{최신_자료}
[질문]
"{사용자_질문}"
위 배경 지식을 활용하여 질문에 정확하고 간결하게 답변하세요.




설명: {최신_자료} 부분에 RAG 검색으로 찾은 관련 문서 조각들을 넣습니다. 모델은 해당 내용을 참고하여 사용자 질문에 답합니다. 이 템플릿은 근거 기반 답변을 위해 고안되었으며, 필요 시 출처를 인용하도록 프롬프트에 추가 지시를 합니다. 예: “출처에 기반하여 답변하고, 확실하지 않은 경우 추측하지 마세요.”


아이디어 브레인스토밍 프롬프트 (Brainstorming Prompt):


용도: 사용자가 새로운 아이디어나 전략이 필요할 때 AI가 다각도로 제안하도록 하는 프롬프트입니다. (예: “마케팅 캠페인 아이디어를 제안해줘”).


프롬프트 템플릿 예시:


사용자의 요청: {사용자_요청}
이에 대해 창의적이고 실용적인 아이디어를 3가지 제시하세요. 각각 번호를 붙여 간략히 설명합니다.




설명: 예를 들어 사용자_요청이 “저예산으로 SNS 마케팅하는 방법”이면, AI는 “1. 인플루언서 협업 챌린지… 2. UGC 이벤트…” 등의 식으로 구조화된 아이디어 목록을 제공합니다. 이 템플릿은 창의성에 중점을 둬, 시스템 메시지로 “비즈니스 상황에 맞고 실현가능한 아이디어”라는 조건을 추가해 제약합니다.


매칭 추천 설명 프롬프트 (Match Recommendation Explanation Prompt):


용도: 매칭 엔진이 선별한 투자자-스타트업 쌍에 대해, AI가 그 근거를 자연어로 서술할 때 사용됩니다.


프롬프트 템플릿 예시:


스타트업: {스타트업_명}, 분야: {산업}, 단계: {단계}
투자자: {투자자_명}, 관심 분야: {투자_선호_산업}, 투자 단계: {선호_단계}
이 두 프로필이 잘 맞는 이유를 한 문장으로 설명:




설명: 시스템이 필터링으로 매칭한 경우를, 사용자에게 “왜 추천되었는지” 설명할 때 활용합니다. 예컨대 “산업/단계 적합” 등의 데이터를 넣으면 AI는 “ABC 투자자는 귀사의 분야(핀테크)에 투자 경험이 있고, 현재 귀사의 단계(시드 단계)에 맞는 펀드를 운영 중입니다.“와 같이 한 문장 설명을 생성합니다. 이는 추천 리스트 UI에 근거를 표시하기 위함입니다. 이 프롬프트는 비교적 간단한 정보를 토대로 하기 때문에 명확히 값을 채워 넣는 방식으로 템플릿화돼 있습니다.


코딩 어시스턴트 프롬프트 (개발용) (Optional):

 (개발팀 내부 사용) Vibe Coding 철학에 따라 AI 코딩 에이전트를 활용하기 때문에, 개발용으로도 프롬프트 템플릿을 정리해 둡니다. 예:


유닛 테스트 생성 프롬프트: "다음 함수의 동작을 설명하는 단위 테스트 코드를 Jest로 작성: + 함수 코드`


리팩토링 제안 프롬프트: "코드 스니펫을 보고 성능을 개선하거나 간결하게 만들 방안을 제안:" + 코드

 이러한 프롬프트들은 개발 생산성을 높이기 위한 것으로, 제품 문서에는 직접 노출되지 않지만 라이브러리에 참고로 포함됩니다. AI에게 일관된 결과를 얻기 위해, 팀은 효과적인 프롬프트들을 모아서 공유하며, 점진적으로 개선해나갑니다.


모든 프롬프트는 한국어 출력을 기본으로 하나, 필요한 경우 (예: 코드 관련) 영문을 섞어 사용할 수도 있습니다. 프롬프트 라이브러리는 AI 응답 품질 향상을 위해 지속적으로 A/B 테스트를 거쳐 최적화되며, 사용자는 UI 상에서 대부분 이를 의식하지 않고 “AI 도움받기” 버튼만 누르면 되도록 추상화되어 있습니다. 하지만 개발 문서로서, 이러한 템플릿을 명시해 두어 프롬프트 엔지니어링 원칙을 공유하고 추후 문제 발생 시 디버깅이나 개선에 활용합니다.
11. RAG 구조 정의 (Vector DB 구조)
RAG(Retrieval-Augmented Generation) 구조는 스타트업쇼의 AI 어시스턴트가 정확하고 최신의 정보를 제공하도록 지원하는 핵심 요소입니다 . 이를 위해 벡터 데이터베이스와 검색-생성 파이프라인을 설계하였습니다:
지식 소스 및 인덱싱: RAG에 활용될 지식은 두 가지 주된 카테고리로 나뉩니다:


스타트업 도메인 일반 자료: 스타트업 운영, 투자, 법률, 회계 등과 관련된 공개 문서 또는 사내 축적 문서 (예: 스타트업 운영 가이드, Q&A 모음)를 사전에 수집합니다. 이를 전처리하여 텍스트 청크로 분할(예: 500자 단위)한 후 임베딩하여 글로벌 지식 벡터DB에 저장합니다.


개별 스타트업 전용 자료: 각 스타트업이 업로드한 데이터룸 문서, 작성한 투자자 업데이트, 주요 지표와 설명 등을 해당 스타트업 전용으로 수집합니다. 이들도 필요한 단위로 청크화(chunks) 하여 임베딩하고, 스타트업 ID별 네임스페이스로 구분된 벡터DB 컬렉션에 저장합니다. 예를 들어, StartupID=ABC인 회사의 문서들은 벡터DB에서 “ABC” 영역에 속하며, 다른 회사 문서와 섞이지 않게 관리됩니다.


임베딩 생성: 임베딩에는 OpenAI의 text-embedding-ada-002 모델 또는 국내 언어에 최적화된 모델을 사용합니다. 각 문서 청크는 해당 모델을 통해 **고차원 벡터(예: 1536차원)**로 변환되며, 이 벡터와 함께 메타데이터로 source_id (원문 문서 식별자), startup_id, section_title 등을 저장해 둡니다. 임베딩 작업은 문서가 새로 추가되거나 수정될 때 백그라운드로 수행되며, 한 번 인덱싱된 벡터는 벡터DB가 유사도 검색을 위해 관리합니다.


벡터 데이터베이스 구조: 선택된 Pinecone 서비스는 내부적으로 HNSW 알고리즘 기반의 벡터 인덱스를 사용하여, 고차원 유사도 검색을 빠르게 처리합니다. 데이터 조직 측면에서,


“글로벌 지식” 컬렉션 (예: global_knowledge)에는 모든 일반 자료 벡터가 들어가 있습니다.


“스타트업별 지식” 컬렉션은 StartupID별로 분리되어 있는데, Pinecone의 metadata filter 기능을 활용해 하나의 인덱스에 넣고 metadata: {startup_id: "ABC"} 필터로 검색할 수도 있고, 각 스타트업마다 별도 인덱스를 생성할 수도 있습니다. 현재 설계에서는 스타트업별 인덱스보다는 단일 인덱스 + metadata 필터 방식을 채택하여 운영의 복잡도를 줄였습니다 (스타트업이 수천 개로 늘어나면 인덱스 관리가 어려워지므로).


각 벡터는 { id: <uuid>, values: [0.123,...], metadata: { startup_id: "...", source_type: "update", source_id: "...", text: "..." } } 형태로 저장됩니다. metadata.text에는 해당 청크의 실제 원문 내용이 저장되어 있어, 검색 결과와 함께 원문을 바로 반환할 수 있습니다.


검색 단계 (Retrieval): 사용자가 AI 어시스턴트에 질문하면, 우선 질문 종류와 맥락에 따라 검색 범위를 결정합니다.


사용자가 “우리 회사 이번 달 매출은?“처럼 특정 스타트업 데이터 질문을 하면 -> 해당 StartupID의 벡터만 검색하는 쿼리를 만듭니다.


사용자가 “직원 스톡옵션 설계는 어떻게 하나요?“처럼 일반 스타트업 지식 질문을 하면 -> global_knowledge 컬렉션을 검색합니다.


명확하지 않은 경우, 기본적으로 글로벌+자기 스타트업 둘 다 검색하고 결과를 조합하거나, 사용자에게 추가 질문으로 의도를 확인할 수도 있습니다.


검색은 벡터DB에 쿼리 임베딩(질문을 같은 임베딩 모델로 변환)을 보내 top-k (예: 5개) 유사한 벡터를 반환받는 방식입니다. Pinecone의 쿼리 예시 (pseudo-code):


results = vector_db.query(vector=query_vec, top_k=5, filter={"startup_id": user.startup_id if scope=="startup" else None})
filter 부분은 scope에 따라 다르게 적용합니다. 응답 결과에는 각 벡터와 유사도 점수, 메타데이터가 포함됩니다.


증강 단계 (Augmentation): 검색된 top-5 벡터의 원문 텍스트를 추출하여 프롬프트에 삽입합니다 . 보통 하나의 프롬프트에 담을 수 있는 맥락은 토큰 제한이 있으므로, 상위 2~3개만 선택하거나, 요약이 필요하면 벡터DB에서 함께 저장된 summary(별도로 생성해 둘 수도 있음)를 사용할 수 있습니다. 증강된 프롬프트 형식은 앞서 프롬프트 라이브러리 Q&A에서 예시한 것처럼 [배경 지식] ... [질문] ... 형태로 구성합니다.


생성 단계 (Generation): LLM에 증강된 프롬프트를 보내 최종 답변을 생성합니다 . 이때 사전에 세팅한 시스템 메시지에는 “당신은 스타트업 쇼 AI 어시스턴트입니다…” 등의 역할과 답변 스타일(간결, 친절한 말투 등)을 지정합니다. 중요하게, 답변에는 가급적 출처를 언급하게 하여 신뢰도를 높이고 환각을 줄입니다 . OpenAI API 호출 예시:


response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[{"role": "system", "content": "... 안내 ..."}, {"role": "user", "content": prompt_text}]
)
answer = response.choices[0].message.content
생성된 answer는 필요 시 후처리(예: 마크다운 표 형식 -> HTML 변환 등)를 거쳐 사용자에게 전달됩니다.


응답 및 피드백: 클라이언트는 AI의 답변을 화면에 표시하고, 만약 출처 링크가 포함되어 있다면 하이퍼링크로 연결합니다. 사용자가 답변에 만족하지 않으면 “재질문”하거나 “추가 질문”을 할 수 있는데, 이 경우 대화 맥락을 연속 유지하여 다시 RAG 프로세스를 수행합니다. (과거 대화를 많은 맥락으로 모두 넣으면 토큰이 급증하므로, 핵심 QA pair를 요약 저장했다가 재검색에 활용하는 등 최적화 기법을 고려).


데이터 업데이트와 재색인: 스타트업의 데이터룸 문서가 변경되거나 새로운 업데이트가 작성되면, 해당 내용이 RAG에 반영되도록 재색인 작업이 트리거됩니다. 구현으로는, 문서 업로드 API나 업데이트 Publish 시점에 백엔드에서 비동기로 해당 컨텐츠를 임베딩 서비스 큐에 넣고, 작업 완료 시 벡터DB를 업데이트합니다. 임베딩 모델은 버전이 변경될 수 있으므로, 모든 벡터에 model_version 메타데이터를 포함시켜 관리하고, 모델이 바뀌면 전체 재생성이 필요할 수 있음을 명시해 둡니다.


RAG의 효과: 이 구조를 통해 스타트업쇼의 AI는 최신 정보 활용, 회사별 전문 지식 사용, 근거제시라는 이점을 얻습니다 . 예를 들어 일반 ChatGPT가 답하지 못하는 최신 법인세 정책 질문도, RAG로 최신 세무 가이드 문서를 넣어주면 정확히 답할 수 있습니다. 그리고 투자자 질문에 대해 회사가 제공한 정확한 데이터 (예: 최근 월간 리포트 내용)을 기반으로 답변하므로 신뢰도가 높습니다. 환각 현상이 줄어들고 답변의 정확성이 향상되어, 사용자들은 AI 어시스턴트를 신뢰할 수 있는 조언자로 느끼게 됩니다.


향후 발전: 현재는 기본적인 Naive RAG 구현이지만 , 향후 질문의 성격에 따라 하이브리드 검색(벡터+키워드), 리랭킹 모델 적용, 질문 의도 분석 후 다단계 질의 등의 고도화된 RAG 기법도 적용할 예정입니다. 또한 내부적으로 QA Pair가 축적되면 이를 파인튜닝하거나, 사내 전용 LLM을 구축하여 프라이버시를 강화하는 방향도 고려됩니다.


요약하면, RAG 구조는 Indexing → Retrieval → Augmentation → Generation의 파이프라인으로 구현되며, Vector DB(Pinecone)와 LLM(GPT-4)을 조합하여 정확도와 신뢰성을 높인 AI 응답 시스템을 구축합니다. 해당 구성은 NVIDIA 등에서 소개된 일반적인 RAG 파이프라인을 준용한 것으로 , 스타트업쇼 서비스의 차별화 요소인 “똑똑한 AI 조언자”를 실현합니다.
12. AI 에이전트 아키텍처 (AI Agent Architecture)
스타트업쇼의 AI 에이전트는 단순 대화형 챗봇을 넘어, 사용자의 지시를 받아 복합적인 작업을 수행할 수 있는 지능형 에이전트입니다. 이를 위해 LLM 기반 에이전트 아키텍처를 도입하였으며, 주요 설계 요소는 다음과 같습니다:
에이전트의 역할 정의: 스타트업쇼 AI 에이전트는 크게 두 가지 모드로 동작합니다:


컨시어지 모드: 사용자의 질문에 답하거나 요청에 따른 작업을 권장/안내하는 모드. 예를 들어 “내일 할 일 목록 만들어줘” 요청에, 내일의 일정과 우선순위를 알려주거나 제안까지 하는 역할입니다.


실행 모드: 사용자의 명시적 명령에 따라 시스템 내 액션을 실제로 수행하는 모드. 예를 들어 “다음주 월요일 오전 10시에 팀 미팅 일정 추가해줘”라고 하면, 실제로 캘린더/일정 모듈을 통해 해당 이벤트를 생성합니다. 이때는 도구(tool) 사용을 통한 액션이 동반됩니다.


프롬프트 체계 및 도구 연결: 에이전트는 LangChain 등의 프레임워크를 활용하여 Thought→Action→Observation→…→Answer의 루프를 수행합니다. 시스템 레벨에서, 에이전트에게 허용된 도구 목록을 정의하여 LLM이 이를 사용해 문제를 해결할 수 있도록 합니다. 스타트업쇼에서 정의한 대표적인 도구:


SearchDocs : 벡터DB나 사내 위키에서 정보를 검색 (RAG 검색과 유사).


QueryDB : 특정 쿼리를 데이터베이스에서 실행. (예: “SELECT revenue FROM metrics WHERE month=…” 형태. 미리 정의된 쿼리만 허용하거나 ORM 레이어 함수 호출로 추상화).


CreateTask : 새로운 과제를 생성하는 API 액션.


ScheduleMeeting : 일정 생성 (외부 Calendar API 연동).


SendUpdate : 최신 업데이트를 특정 투자자에게 발송하는 액션.


이러한 도구들은 내부적으로 REST API 호출 또는 서비스 로직을 캡슐화한 함수들입니다. LLM에게는 도구명과 사용법(signature)을 JSON이나 함수 형태로 알려주고, LLM이 필요 시 적절한 arguments를 채워 함수를 호출하도록 합니다. (OpenAI function calling 기능 활용 시 함수 스펙 정의하여 GPT에게 넘김)


예시 시나리오: “매출 상승률 계산하고 리포트 작성해줘”라는 사용자 명령을 처리하는 내부 흐름:


에이전트(LM)는 우선 생각(Thought) 단계에서 “사용자가 매출 상승률(전월 대비) 계산과 보고서 작성 원함”을 파악.


Action: QueryDB 도구를 호출하여 (예: QueryDB("SELECT current_revenue, last_month_revenue FROM metrics WHERE startup_id=...?")).


Observation: DB에서 결과를 받아옴 (예: 1000, 800).


Thought: “상승률 25%임을 계산. 보고서 작성을 위해 업데이트 초안 필요.”


Action: SendUpdate 도구를 호출하여 (예: SendUpdate(draft="지난달 대비 매출이 25% 증가했습니다. 주요 원인은 ...", target="self") - self에게 초안을 저장).


Observation: 업데이트 초안이 생성되고 ID 반환.


Answer: 사용자에게 “매출이 25% 상승하여, 그에 대한 업데이트 초안을 작성해두었습니다.“라는 최종 답변 출력.


이처럼 에이전트는 문제를 해결하기 위해 순차적으로 도구를 사용하며, 각 단계의 결과를 평가하여 다음 액션을 결정합니다. 이러한 일련의 과정은 LLM의 Chain-of-Thought에 의해 구동되며, 우리의 시스템은 중간 상태(Action, Observation)을 로그로 기록하여 투명성을 유지합니다.


제어 및 제한: 에이전트에게 도구 사용의 허용 범위와 제약을 명시합니다. 예를 들어:


DB 쿼리 도구는 READ 전용으로 하고, WRITE는 불가능하게 한다 (데이터 손상 위험 방지).


일정 생성 도구는 사용자 본인의 캘린더에만 추가 가능하게 하고, 외부 투자자 캘린더엔 추가를 못한다.


매우 파괴적인 도구 (사용자 계정 탈퇴 등)는 아예 노출하지 않거나, 사용하더라도 confirm=True 파라미터를 요구해 사람 승인 없이는 실행 결과를 commit하지 않게 합니다.


또한 루프 탈출 조건을 설정해 LLM이 잘못된 루프에 빠지지 않도록 합니다. 예: 최대 3회 Action 시도 후 답변하도록 제한. 만약 답을 못 찾으면 사과 메시지와 함께 도움말을 제시.


상태 유지 및 컨텍스트: 에이전트는 멀티턴 대화를 기억하기 위해 대화 내역을 컨텍스트로 받습니다. LangChain 메모리나 OpenAI 대화 히스토리 기능을 이용해, 사용자가 이전에 말한 목표나 받은 정보를 다음 질의에 활용합니다. 다만 중요한 실시간 데이터(예: 방금 생성된 Task ID)는 별도로 상태로 관리하여, 필요시 LLM에 넣어줍니다.


모니터링과 피드백: 에이전트 행동은 로그에 세부 기록됩니다 (어떤 도구를 어떤 인자로 호출했고 결과가 어땠는지). 이 로그를 주기적으로 모니터링하여 잘못된 사용 패턴이나 실패 사례를 수집합니다. 예를 들어 LLM이 QueryDB에 잘못된 SQL을 주입하려 시도하면, 로그에 남기고 사전에 학습시켜 수정하거나, LLM 시스템 프롬프트를 조정하여 그런 요청을 안 하도록 합니다. 또한 사용자가 에이전트 결과에 불만족 시 직접 피드백을 보내면 (thumbs down 등 UI 제공), 이를 트래킹해 향후 프롬프트 개선에 활용합니다.


사용자 승인 흐름: 실행 모드에서 민감한 작업은 사용자 컨펌 UI를 거칩니다. 예를 들어 “팀원 모두에게 업무 리마인드 이메일 보내” 요청을 하면, 에이전트가 임시로 이메일 초안을 작성하고 SendEmail(draft=..., confirm=True) 식으로 호출하면 시스템이 바로 보내지 않고, 클라이언트에 “이런 내용을 팀원 5명에게 보내시겠습니까?” 확인창을 띄웁니다. 사용자가 승인하면 그제서야 실제 발송 API를 호출합니다. 이를 통해 에이전트의 잠재적 오작동으로 인한 사고를 예방합니다.


기술 스택: 구현은 현재 OpenAI GPT-4 API와 LangChain 라이브러리를 고려 중입니다. Node.js 환경에서도 function calling을 통해 일부 구현 가능하나, 복잡한 multi-step reasoning은 Python LangChain이 성숙하므로, Python 서비스를 사용하는 방향이 유력합니다. 에이전트의 도구 세트를 Python에서 구현하고 gRPC/REST 인터페이스로 Node 메인 서버와 통신하는 구조입니다. 응답 지연을 최소화하기 위해 비동기 요청 처리와 스트리밍 응답(예: 답변을 타이핑되는 대로 전송)도 적용합니다.


정리: AI 에이전트 아키텍처는 도구 집합 + LLM으로 구성되어 사용자의 고차원 요청을 처리합니다. 사람과 비슷한 문제 해결 절차를 따르되, 시스템이 미리 정의한 안전장치와 권한 시스템 내에서만 행동하도록 제한되어 있습니다. 이를 통해 스타트업쇼 플랫폼은 단순 질의응답을 넘어, 사용자 업무를 실제로 도와주는 능동적 AI 비서를 제공하며, 이는 경쟁 서비스와의 차별점이 됩니다.
13. 코딩 컨벤션 (Coding Convention)
스타트업쇼의 개발팀은 일관된 코드 스타일과 품질 유지를 위해 다음 코딩 컨벤션을 준수합니다. 프론트엔드(Typescript/React)와 백엔드(Node.js, Python 등 각각의 언어)에 대한 규칙을 분류하고 공통 사항을 정의합니다.
공통 원칙:
이름 짓기(Naming): 모든 식별자는 의미를 명확히 나타내도록 영어로 기술합니다. 줄임말은 지양하며 (예: applyDiscount() 권장, applDscnt() 지양), 일관된 카멜케이스/파스칼케이스 규칙을 따릅니다.


변수, 함수: camelCase (예: totalRevenue, calculateGrowth).


클래스, 타입(인터페이스): PascalCase (예: InvestorProfile, StartupService).


상수: UPPER_SNAKE_CASE (예: MAX_RETRY_COUNT).


파일/디렉토리: 소문자와 대시 또는 스네이크 (kebab-case or snake_case)로, 언어 관습을 따릅니다. (Node backend는 camelCase 폴더 사용하기도 하지만 여기선 소문자 추천).


주석 및 문서화: 함수 또는 모듈의 public API에는 JSDoc/Docstring을 작성하여 용도, 매개변수, 반환값을 설명합니다. 구현 내부 로직은 필수적인 경우에만 주석을 달고, 과도한 주석은 피합니다. 코드만으로 의도가 명확하도록 노력하고, 복잡한 알고리즘에는 단계별 주석을 추가합니다. 주석은 영어를 원칙으로 하되, 도메인 지식 설명(예: 금융 용어 설명)은 필요한 경우 한국어로 추가합니다.


코드 레이아웃: 들여쓰기는 2칸(space 두 개) 또는 4칸을 팀으로 합의하여 사용합니다 (JavaScript/TypeScript는 2칸, Python은 4칸). 80-120자 정도로 한 줄 길이를 제한하고, 긴 표현은 적절히 개행합니다. 중괄호 {}는 K&R 스타일로 작성하며, 조건문, 반복문 등에는 항상 중괄호를 사용해 단일 실행문이라도 명확히 감싸줍니다.


세미콜론 및 콤마: JavaScript/TypeScript에서는 세미콜론 ;을 명시적으로 찍습니다 (ASIH의 모호성 제거). 마지막 요소의 콤마는 trailing comma 허용하여 diff 편의성 확보합니다. Python에서는 PEP8을 따르며, 불필요한 세미콜론은 쓰지 않습니다.


공백과 개행: 연산자 사이, 콤마 다음 등에는 적절한 공백을 넣어 가독성을 높입니다. 예: if (isValid && count > 0) { ... }. 함수 정의나 조건식이 긴 경우 여러 줄로 나누고 각 줄 들여쓰기 정렬합니다. 파일 마지막에는 항상 newline 한 개를 유지합니다.


프론트엔드(React/TypeScript) 컨벤션:
폴더 구조: 기능별 모듈화. 예를 들어 src/features/investor/InvestorDashboard.tsx, 스타일과 훅, 유틸은 각 기능 폴더 내 분리 (InvestorDashboard.module.css, useInvestorData.ts 등). 공통 컴포넌트는 src/components에 위치.


컴포넌트 작성:


함수형 컴포넌트를 사용하며, React Hooks를 통해 상태 관리합니다. 클래스형은 사용하지 않습니다.


컴포넌트 파일 하나에 복수의 컴포넌트를 정의하지 않고, 한 파일에는 한 컴포넌트를 export default 합니다. 필요한 하위 컴포넌트는 파일 하단에 정의하되, 핵심 export에 포함시키지 않습니다.


JSX에서는 self-closing 태그 규칙을 지킵니다 (<MyComponent prop="x" />). 중첩 레벨이 깊어지면 의미 단위별로 줄바꿈하고 들여씁니다.


Props와 State의 타입은 명시적으로 정의합니다 (Type or Interface). any 사용을 지양하며, 불가피한 경우 타입 주석과 함께 왜 any인지 주석을 남깁니다.


스타일링: CSS 클래스 이름은 BEM 방법론을 응용하여 component-name__element--modifier 형식으로 합니다. 혹은 CSS Modules를 쓰는 경우 CamelCase로 mapping된 클래스명을 사용합니다. 인라인 스타일은 동적 계산이 필요한 최소한의 경우만 사용하고 대부분 CSS/SCSS 파일로 관리합니다.


상태 관리 및 데이터 흐름: 전역 상태가 필요할 경우 Redux Toolkit을 사용하며, slice별로 파일 분리하고 action과 reducer에 immer 등을 활용해 불변성 유지합니다. 컴포넌트 내부 상태는 useState로 관리하되, 복잡한 로직은 custom hook으로 추출합니다. API 호출은 useEffect와 axios/fetch를 사용하며, 응답 데이터는 필요한 경우 전처리 후 state에 저장합니다.


린팅 및 포매팅: ESLint (Airbnb 기반)와 Prettier를 적용하여, 저장 시 자동 정렬/포매팅을 하도록 IDE 설정을 공유합니다. ESLint 규칙 예: no-unused-vars, react-hooks/exhaustive-deps 등 경고를 모두 해결하는 것을 원칙으로 합니다. commit 전 Husky hook으로 lint 검사를 통과해야 하며, 통과하지 못하면 수정 후 커밋합니다.


백엔드(Node.js & Python) 컨벤션:
Node.js (JavaScript/TypeScript): 백엔드는 TypeScript로 작성하며, tsconfig는 strict 모드 사용으로 noImplicitAny, strictNullChecks 등을 활성화합니다.


Express 컨트롤러에서는 async/await 사용하여 Promise 처리하고, try-catch로 오류를 잡아 next(err)로 전달하거나, 표준화된 오류 응답 형태를 반환합니다. console.log 디버깅은 개발 중에만 사용하고, 실제 코드에는 Winston 등의 로거로 치환합니다.


서비스/비즈니스 로직에서는 한 함수의 길이가 가능하면 50줄 내로 유지되도록 리팩토링하며, 너무 복잡하면 적절히 private 함수로 쪼갭니다.


오류 메시지는 개발용(로그)과 사용자용(응답)을 구분하고, 민감한 정보(스택 트레이스 등)는 사용자에게 노출하지 않습니다.


Package 구조: controllers, services, models 디렉토리로 구분하고, 파일명은 기능명으로 (예: user.controller.ts, user.service.ts, user.model.ts). 라우터는 /routes/user.ts 등으로 분리하며, express 라우터 설정 시 중첩 라우트는 가급적 피하고 RESTful하게 분리합니다.


Python (AI 모듈 등): PEP8 표준 준수. 4 space indent, 함수/변수는 snake_case, 클래스는 PascalCase. 타입 힌트를 적극 사용하고, mypy 등으로 정적 타입 체크를 활용합니다.


복잡한 알고리즘 (예: 벡터 처리 코드)은 step별로 주석 및 docstring을 작성합니다.


모듈 임포트 순서는 PEP8에 따라 표준 라이브러리, 써드파티, 자가 모듈 순으로 구분하고, 각 그룹 사이 빈 줄로 구분합니다.


길이 80자를 권장하지만, 최대 100자까지 허용하고 그 이상은 줄바꿈.


Lambda 등 익명함수는 간단한 경우만 쓰고, 복잡하면 def로 정의합니다.


Logging은 Python logging 모듈 사용, print로 디버깅 금지.


데이터베이스 쿼리: ORM을 쓰더라도 raw SQL 작성이 필요한 경우, 대문자 키워드, 소문자 식별자 스타일로 통일합니다:


SELECT id, name FROM users WHERE email = ?;
여러 줄 SQL은 백틱 멀티라인 또는 템플릿 스트링으로 작성 시 개행 정렬을 신경씁니다. ORM 모델 클래스는 PascalCase로, 필드명은 스네이크로 (ORM이 자동 매핑).


Git Commit Convention (관련하여 Git 전략 문서에도 있지만): 코드에 영향 가므로 간략히 언급하면, commit 메시지는 영어 현재형으로 “Add user login API”, “Fix bug in update publish”처럼 작성하고, 여러 작업이 섞이지 않게 한 커밋엔 한 가지 변경사항을 담습니다.


패턴 및 Best Practice:
DRY (Don’t Repeat Yourself): 유사한 코드가 3곳 이상 나타나면 공통 함수나 컴포넌트로 리팩토링합니다. 유틸리티 함수들은 utils 디렉토리에 모아두고, cross-cutting concern(예: 날짜 포맷, 인증 토큰 처리)은 미들웨어나 헬퍼로 추출합니다.


에러 처리: 모든 에러는 누락 없이 처리합니다. Promise 체인은 .catch, async 함수에는 try-catch, Python에서는 예외 처리 후 로그와 raise 등을 통해 상위로 전달. 예상 가능한 에러상황 (예: DB unique 제약 위반)은 코드 내에서 특정 에러타입으로 캐치하여 사용자 친화적 메시지를 주도록 합니다.


메모리/성능: 큰 데이터 처리는 스트리밍을 고려합니다. 예를 들어 대용량 리스트 응답은 pagination, limit 사용. 클라이언트에서 필요없는 데이터까지 조회하지 않도록 SELECT 필드 제한, ORM eager/lazy 적절히 조정 등 튜닝을 적용합니다. 알고리즘 복잡도도 고려하여 O(n^2) 반복을 피하고, 필요한 곳에 캐싱합니다.


환경 설정: API 키, DB 비밀번호 등 민감정보는 코드에 하드코딩하지 않고 .env로 관리하며, 코드에는 process.env.KEY_NAME으로 참조합니다. 환경 변수 키 이름은 모두 대문자 스네이크로 지정합니다. 개발/스테이징/프로덕션 환경별 설정 파일을 두어 혼동 없도록 합니다.


코딩 컨벤션은 코드리뷰 과정에서 지속적으로 적용/검토되며, 팀 내 컨벤션 문서에 추가 사례와 예외사항이 기록됩니다. 모든 신규 입사자는 이 가이드를 숙지하고 따르며, 자동화된 린트/포매터 설정으로 이를 지원합니다. 일관된 컨벤션 준수는 코드 품질과 협업 효율 향상에 필수적이며, 우리 팀은 이를 엄격히 유지합니다.
14. Git/Branch 전략 (Git/Branch Strategy)
원활한 협업과 안정적인 출시를 위해 Git 브랜치 전략을 수립하고 따릅니다. 우리 프로젝트는 Gitflow Workflow를 기본으로 약간 변형한 전략을 사용합니다 . 주요 요소는 다음과 같습니다:
메인 브랜치(Main branch): 배포 가능한 안정 버전을 관리하는 브랜치로, main (또는 master)를 사용합니다. 이 브랜치는 항상 배포 가능한 상태를 유지하며 , 모든 완료된 기능과 검증된 코드를 머지합니다. CI 파이프라인은 main에 push될 때 프로덕션 배포를 트리거합니다.


개발 브랜치(Develop branch): 다음 출시 버전을 개발하는 브랜치로, develop 브랜치를 운영합니다 . 개발중인 기능들이 이 브랜치에서 통합되며, QA/Staging 환경 배포는 develop 기준으로 이뤄집니다. main에 병합되기 전의 테스트 베드 역할을 하므로, 통합 테스트를 거친 후 main으로 머지합니다.


기능 브랜치(Feature branches): 각 기능이나 개선 작업마다 별도의 브랜치를 생성합니다 . feature 브랜치 이름은 짧고 의미있게 짓습니다: 예) feature/login-page, feature/investor-matching. 기능 브랜치는 항상 최신 develop 브랜치에서 분기하고, 구현 완료 후 다시 develop으로 PR을 보내 머지합니다. 머지 시에는 –no-ff 옵션(fast-forward 방지)을 사용하여 머지 커밋을 생성, 이로써 나중에 이 기능의 커밋 이력을 한 눈에 파악할 수 있습니다 . 작업 완료 후 feature 브랜치는 삭제하여 저장소를 정리합니다.


버그 수정 브랜치(Bugfix/Hotfix branches): QA 중 발견된 버그 수정은 develop에서 분기한 bugfix/... 브랜치로 처리하고 develop으로 머지합니다. 프로덕션에서 급한 치명적 버그 발생 시에는 main에서 직접 hotfix/... 브랜치를 만들어 수정하고, main에 머지 (즉시 배포)한 뒤 이 변경을 develop에도 반영합니다 . hotfix 브랜치는 배포 주기를 기다리지 않고 빠르게 패치하기 위함이며, version tag를 붙여 관리합니다.


릴리스 브랜치(Release branches): 일정 기간(예: 2주 스프린트) 개발이 완료되면, 배포 준비를 위해 develop에서 release-x.y.z 브랜치를 분기합니다 . 이 브랜치에서 QA팀이 종합 테스트를 수행하고, 필요한 작은 수정(버그 fix, 버전업데이트, docs 변경 등)만 적용하며 새로운 기능 추가는 중단합니다. 준비 완료 후 release 브랜치를 main에 머지하여 배포를 실시하고, 동시에 release 브랜치 변경분을 develop에도 병합하여 develop을 다음 싸이클 시작점과 동기화합니다 . 그런 다음 release 브랜치는 삭제합니다. 각 출시 버전은 main에 머지되는 커밋에 Git 태그(예: v1.3.0)를 달아 이력 관리를 합니다.


네이밍 규칙: 브랜치 이름은 소문자와 슬래시(/)로 구분합니다. 종류별 prefix를 붙여 한눈에 용도를 파악합니다: feature/, bugfix/, hotfix/, release/. 뒷부분에는 Jira 티켓 번호나 작업 키워드를 포함시킵니다. 예: feature/INV-123-invite-investor-flow, bugfix/INV-342-null-pointer.


커밋 메시지 규칙: 모든 커밋은 Conventional Commits 스타일을 따릅니다. 즉, feat: 투자자 초대 화면 구현 혹은 fix: 업데이트 발행 시 날짜 형식 오류 수정처럼 타입(feat, fix, docs, refactor, test 등)과 한글로 요약 메시지를 작성합니다. 필요 시 상세 설명을 본문에 추가할 수 있으며, 여러 커밋이 복합적으로 연결되는 경우 마지막 커밋 메시지에 “Resolve: #Jira123” 식으로 이슈 트래커 연동도 합니다. 커밋은 논리적인 단위로 작게 나누는 것을 권장하며, 린트/포매팅만 수행한 커밋은 chore: format code 등으로 명시합니다.


Pull Request 정책: feature 브랜치를 develop에 합칠 때, GitLab/GitHub의 **Pull Request(PR)**를 사용합니다. PR 제목은 작업 내용을 요약하고, 설명에는 해당 기능의 목적, 변경사항, 영향을 받는 모듈, 테스트 결과 등을 적습니다. 코드리뷰는 최소 1명 이상의 동료 개발자가 수행하며, 중요한 변경(아키텍처 수정 등)은 시니어 개발자 혹은 Tech Lead의 승인을 받습니다. 코드리뷰자는 스타일 준수, 기능 정상 동작, 보안, 주석 등을 확인하고 approve 또는 change request를 남깁니다. CI 파이프라인(테스트, 린트)이 PR마다 자동 실행되어 모두 통과해야 머지가 가능하도록 설정합니다.


병합 전략: 기본적으로 Squash and Merge를 사용하여, feature 브랜치의 모든 커밋을 하나로 스쿼시하여 develop에 머지합니다. 이로 인해 develop의 히스토리는 깔끔한 단위별 커밋으로 유지됩니다. 단, 동시에 여러 사람이 협업한 큰 기능의 경우, Squash 대신 Merge commit 유지(no squash)를 하여 기여자 커밋을 보존하기도 합니다. Hotfix나 Release 병합 시에는 merge commit을 사용하여 이력을 명확히 구분합니다. main←release, develop←release 병합 시 –no-ff를 항상 적용해, 릴리스 단위가 커밋 그래프에 남습니다.


브랜치 보호: main과 develop 브랜치는 보호 설정되어 인가된 리뷰어 승인 없이 푸시할 수 없습니다. 또한 force push는 금지됩니다. CI 통과 필수, 리뷰 필수 조건을 강제해 안정성을 높입니다. 릴리스 브랜치도 QA 완료 전까지 보호하거나, 담당자 외 푸시 못하도록 제어합니다.


Git Workflow 사례:


개발자는 이슈 할당 받으면 Jira 티켓 번호 확인 → feature/JIRA-123-some-feature 브랜치 생성 → 개발 진행, 여러 커밋 → 로컬 테스트 통과 후 원격에 push.


PR 생성 → 자동 CI (빌드, 테스트) 실행 → 리뷰어 코드리뷰 → 피드백 반영 추가 커밋.


리뷰 승인 & CI 통과 → Squash Merge로 develop에 반영. → CI가 develop 기반 Staging 배포.


스프린트 종료 시, release-1.0 브랜치 생성 → QA 테스트 → 수정 (여기서는 release 브랜치에 직접 커밋 또는 작은 PR) → 완료 후, release-1.0 PR을 main에 merge (Release 태그 달기) 및 develop에도 merge. → main 배포.


태깅 및 버전 관리: Semantic Versioning을 따라 X.Y.Z 형태 버전을 관리합니다. 새로운 기능 릴리스는 마이너 버전++, 큰 변경(호환성 깨지는)은 메이저 버전++, 버그픽스/자잘한 개선은 패치 버전++ 합니다. main에 머지될 때 해당 커밋에 git tag vX.Y.Z를 달고 CI/CD 파이프라인은 이 태그를 빌드 이름으로 사용해 배포합니다.


요약: Git/브랜치 전략은 개발 흐름을 구조화하여 팀원들이 충돌 최소화하면서 동시에 작업하고, 버전 릴리스를 체계적으로 진행할 수 있게 합니다. Gitflow 모델을 따르되, 작은 팀에 맞게 release 브랜치를 선택적으로 사용하고, PR 기반 코드리뷰를 엄격히 하는 것이 포인트입니다. 이 전략을 통해 코드 품질과 출시 안정성 모두 잡는 개발 프로세스를 운영합니다.
15. 테스트 가이드 (Testing Guide)
테스트 가이드는 스타트업쇼 소프트웨어에 대한 품질 보증 전략과具具具, and execution details are not intimately available.  The question expects me to detail a comprehensive test strategy. I must ensure thorough coverage of unit, integration, E2E tests, and mention continuous integration etc. Probably ended abruptly with “품질 보증 전략과具具具”, maybe truncated.
Maybe I reached some token limit in analysis generation. I should resume from test guide (15) properly:
We need to complete section 15 onwards: Testing Guide, Deployment, Security, Onboarding, Investor Viewing Flow, Matching Logic.
The final answer ended abruptly mid-sentence at test guide.
We need to ensure the final answer is continuous and complete all sections through 20.
It seems the final answer cut off at test guide:
We have “## 15. 테스트 가이드 (Testing Guide)
테스트 가이드는 스타트업쇼 소프트웨어에 대한 품질 보증 전략과具具具, and execution details are not intimately available.”
I see nonsense at end: “具具具”, maybe something went wrong.
Maybe message got truncated. Possibly due to length.
We may need to shorten or ensure we don’t exceed some limit.
Given it cut mid-sentence, likely some limit reached.
We should attempt to finalize from where it cut:
I suspect it cut in test guide, so probably we must provide test guide, deployment, security, onboarding, investor flow, matching logic all summarised.
But the instruction said “user will wait a long time for answer so be very comprehensive”.
Given it cut, probably it hit the output limit.
We may attempt to output the remainder separate or compress some.
Alternatively, maybe I should split or at least complete in a second part.
However, I likely need to produce entire answer as one. Possibly the final messaging might have a token limit.
The output seems around 17000 tokens possibly.
I can try to compress the remaining sections a bit to fit.
Or perhaps cut some detail from earlier? But we wrote a lot.
Maybe we try to generate the remainder:
We know what to cover:
15. Testing Guide: talk about unit, integration, e2e, CI pipelines, coverage, test environment, mention AI code test necessity, and perhaps cite [4†L51-L59] about need to test AI code thoroughly.
Deployment Strategy: mention environment separation, CI/CD, maybe containerization, auto deploy triggers, mention if using AWS or etc, mention rolling or blue/green.

 Focus not to be as extremely detailed as previous sections to not overrun.


Security/Permission Document: mention RBAC roles and what each can do, encryption, OWASP best practices, data permission flows, mention possibly compliance if needed.


Onboarding Guide: developer onboarding: environment setup etc (we have some points in planning), user onboarding: for startup and for investor usage (initial steps). Possibly separate headings in that section.


Investor Viewing System & Permission flow: detail the permission states, flows we partly covered in UX flows and features, but ensure clarity in doc style (maybe more technical focus on permission checks, states, UI differences). Could reference how investor and startup connect and what investor can see.


Startup ↔ VC Matching logic: algorithm specifics, data used, mention maybe machine learning in future but currently rule-based by matching categories, mention maybe scoring formula, and how it’s integrated (like maybe run offline or on search queries).


Try to compress a bit the language if possible to ensure it fits.
Let’s attempt to continue the final answer from 15 onward.## 15. 테스트 가이드 (Testing Guide)
테스트 전략 개요: 스타트업쇼는 **단위 테스트(Unit Test)**부터 통합 테스트(Integration Test), **종단 간 테스트(E2E Test)**까지 여러 수준의 테스트를 수행하여 품질을 보증합니다. 자동화된 테스트를 통해 코드 변경 시 기능이 안정적으로 동작함을 확인하며, AI 코드의 특성상 결과 검증을 위한 휴먼 체크도 일부 병행합니다. CI 파이프라인에서 모든 테스트가 통과해야만 코드가 병합/배포되도록 규정해 품질 게이트를 설정합니다.
단위 테스트(Unit Tests): 모든 비즈니스 로직 함수, 컴포넌트, 모듈에 대해 단위 테스트를 작성합니다. 프론트엔드는 React 컴포넌트의 출력 및 이벤트를 Jest + React Testing Library로 테스트하고, 백엔드는 서비스/유틸 함수의 다양한 입력/출력 케이스를 Jest로 검증합니다. Python AI 모듈은 PyTest를 사용합니다.


각 유닛 테스트는 독립적으로 수행되도록 하며, DB나 외부 API 호출이 필요하면 Mocking 기법으로 격리합니다 (예: DB 연동 함수는 in-memory sqlite 또는 Jest mocking, 외부 API는 pytest-mock이나 unittest.mock 사용).


예: 투자자 접근 승인 함수에 대해 “이미 승인된 경우 오류 발생”, “정상 승인 시 상태 변경” 등을 시나리오별로 테스트합니다. AI 관련 함수(예: 프롬프트 생성기)는 예상 프롬프트 문자열이 잘 만들어지는지, 특정 금지어 필터 함수는 의도대로 동작하는지 등을 검증합니다.


코드 커버리지 목표: 전체 코드의 80% 이상 커버리지를 목표로 하며, 핵심 모듈(권한 시스템, 금융 계산 등)은 90% 이상 달성을 추구합니다. CI에서 커버리지 리포트를 산출하여 기준 미달 시 경고 또는 머지 차단합니다.


통합 테스트(Integration Tests): 통합 테스트는 주요 컴포넌트 간 연계를 검사합니다. 예를 들어 API 레이어 테스트를 위해 실제 DB (테스트 전용 DB)와 함께 Express 서버를 띄우고, 슈퍼테스트(SuperTest)로 HTTP 요청을 보내 전체 요청-응답 사이클을 검증합니다.


시나리오 예: “투자자 접근 요청 → 승인 플로우”: 투자자 계정으로 접근 요청 API 호출, 그 후 창업자 계정으로 승인 API 호출, DB에서 InvestorAccess 상태 확인, 그리고 이메일 발송 모듈이 호출되었는지(Mock으로) 확인.


프론트엔드도 통합 수준으로 Redux 스토어와 리듀서, Saga 등이 기대대로 작동하는지 테스트합니다. Jest로 store에 액션을 디스패치하고 최종 state나 효과를 검증합니다.


데이터 준비: 통합 테스트 전에 고정된 시드 데이터를 로드하여 일관된 환경을 마련합니다. ex) 테스트용 SQLite에 migration 실행 및 시나리오에 맞는 기본 유저/스타트업 삽입. 테스트 종료 후 cleanup.


E2E 테스트(End-to-End Tests): 실제 사용자의 시나리오를 브라우저 환경에서 테스트하기 위해 Cypress 또는 Playwright를 사용합니다. Staging 환경에서 애플리케이션을 띄운 후, 시나리오별로 브라우저를 자동 조작하여 UI가 의도대로 동작하고 백엔드까지 포함한 전 과정이 잘 수행되는지 확인합니다.


주요 E2E 시나리오:


“신규 스타트업 등록 플로우”: 회원가입 → 스타트업 생성 → 팀원 초대까지 UI 상에서 진행, 최종적으로 DB에 팀원 기록 존재 확인.


“과제 생성/완료 및 알림”: 과제 추가 UI 동작 → 완료 처리 → 해당 담당자에게 알림 배지 증가 확인.


“투자자 권한 요청~승인”: 투자자 계정으로 요청 버튼 클릭 → 창업자 계정 화면에 알림 및 승인 처리 → 투자자 화면에 데이터룸 접근 가능 여부 확인.


“AI 어시스턴트 응답 표시”: 챗봇 아이콘 클릭 → 질문 입력 → 로딩 후 답변 텍스트 노출 및 링크 클릭 시 올바른 페이지 이동 확인.


E2E 테스트는 테스트용 시드 데이터를 가진 테스트 환경(Staging with dummy data)에서 진행하며, 중요 시나리오는 PR 머지 전에 로컬 혹은 CI서버 브라우저에서 headless로 실행합니다.


AI 기능 테스트: AI의 응답은 확률적이므로 스냅샷 테스트나 허용 오차 범위 테스트를 적용합니다. 예를 들어, 프롬프트에 대해 기대하는 키워드가 응답에 포함되는지, 금지된 표현이 없는지 등을 검사합니다. OpenAI API 호출은 비용 문제로 Mock으로 대체하여, 미리 캡처한 예시 응답을 반환하도록 합니다. 다만 주기적으로 실제 AI를 호출한 결과를 사람이 검수하여 테스트 fixture를 업데이트합니다.


AI 코드 품질 이슈를 위해, AI가 생성한 코드나 결과를 항상 검토하고 테스트함을 명심합니다 . 특히 에이전트의 액션 결정 로직은 시뮬레이션 테스트 (가짜 사용자 명령을 입력하여 일련의 Action sequence가 예상대로 나오는지)로 검증합니다.


성능 테스트 & 부하 테스트: 주요 API에 대해 JMeter 등으로 부하 테스트를 실시합니다. 예: 다수 투자자가 동시에 데이터룸 다운로드 시 응답 시간, 1분당 챗봇 문의 처리량 등. 목표는 Peak 시에도 응답 지연이 허용 범위 내인지 확인하는 것입니다. 식별된 병목에 따라 쿼리 최적화나 캐싱 적용 후 다시 측정합니다.


또한 메모리 릭 테스트 (특히 Node 서버), 장시간 동작시 성능 저하 여부 등을 모니터링합니다.


테스트 환경: 개발 단계에서 로컬 테스트를 쉽게 하도록, npm test (프론트) / pytest / npm run test:ci 등을 구성해두었습니다. CI에서는 GitHub Actions 또는 Jenkins에서 테스트 컨테이너를 띄워, 테스트용 DB와 필요한 서비스(redis 등)를 포함한 docker-compose 환경에서 모든 테스트를 실행합니다. 테스트 결과는 콘솔과 리포트(jUnit, cobertura 등)로 출력되고, 실패 시 빌드를 빨간색으로 표시하여 즉시 인지하게 합니다.


로컬에서 E2E를 돌릴 때는 Cypress GUI 모드로 개발자가 테스트를 보면서 debug 할 수 있고, CI에서는 headless mode로 브라우저 창 없이 수행합니다.


테스트 주기: 단위 테스트와 통합테스트는 개발자가 기능 구현 시 수시로 실행합니다 (TDD 권장). PR 생성 시 자동으로 수행되고, main 배포 전에는 전체 테스트 스위트를 한 번 더 돌립니다. E2E 테스트는 빌드/배포 주기마다 스테이징 환경에서 nightly로 돌리거나, 핵심 시나리오는 매 PR시 실행하여 회귀를 빨리 발견합니다.


요약: 테스트는 Shift-left 원칙에 따라 가능한 한 초기에, 다양한 레벨에서 진행합니다. 이를 통해 기능이 요구사항대로 동작하는지, 새로운 코드가 기존 기능을 망가뜨리지 않았는지 지속 검증합니다. 특히 AI 코드에 대해서는 결과를 맹신하지 않고 반드시 인간 검증 및 충분한 케이스 테스트를 거쳐 신뢰성을 담보합니다. 이러한 다층적인 테스트 전략으로 스타트업쇼의 신속한 개발 속도에도 품질을 유지할 수 있습니다.
16. 배포 전략 (Deployment Strategy)
스타트업쇼는 지속적 통합/배포(CI/CD) 파이프라인을 구축하여 코드 변경이 신속하고 안정적으로 프로덕션에 반영되도록 합니다. 배포 전략은 개발환경→스테이징→프로덕션의 다중 단계를 거치며, 자동화와 무중단 원칙을 따릅니다.
인프라 환경: 클라우드 기반으로 초기에는 AWS를 사용합니다. 애플리케이션은 Docker 컨테이너화하여 배포하며, 컨테이너 오케스트레이션은 AWS Elastic Beanstalk 또는 ECS Fargate를 이용해 간편히 관리합니다 (향후 트래픽 증가 시 Kubernetes(EKS)로 전환 고려). 데이터베이스는 AWS RDS(PostgreSQL), 정적 파일은 S3, 도메인과 SSL은 CloudFront+ACM 조합을 활용합니다.


프론트엔드는 정적 빌드(output된 HTML/CSS/JS) 후 CloudFront CDN을 통해 서빙하고, 백엔드 API 서버는 ECS 서비스로 배포하여 Application Load Balancer(ALB)를 거쳐 트래픽을 처리합니다.


AI 벡터DB는 관리형 SaaS(Pinecone)로 두고, LLM API 호출은 외부(OpenAI)로 하기 때문에 해당 부분은 인프라에 포함되지 않습니다. 다만 AI Python 서비스(있다면)는 별도 ECS 혹은 Lambda(서버리스)로 배포 가능합니다.


CI (지속적 통합): GitHub Actions를 사용하여 코드 푸시마다 빌드/테스트/코드분석이 자동 실행됩니다. 주요 Workflow:


PR 빌드: 모든 PR에 대해 install -> lint -> test 작업이 진행되어, 린트/테스트를 통과하지 못하면 머지 불가하게 합니다. 프론트엔드는 npm run build로 빌드 가능 여부 확인, 백엔드는 npm run build-ts(TypeScript 컴파일)로 확인합니다.


Docker Build: main 또는 develop 브랜치에 변경이 머지되면, CI가 Docker 이미지를 빌드하고 레지스트리에 푸시합니다. 예: glowus-web:staging-{gitSHA}, glowus-api:staging-{gitSHA}. 이 이미지를 다음 CD 단계에서 사용합니다.


CD (지속적 배포) 파이프라인:


개발(Staging) 배포: develop 브랜치에 머지되면 자동으로 스테이징 환경에 배포되도록 설정합니다. GitHub Actions 또는 Jenkins가 새로운 Docker 이미지를 태그 staging-latest로 푸시하고, AWS EB/ECS에 배포 명령(API 호출)을 실행합니다. 스테이징에는 sample 데이터베이스 또는 production과 유사한 설정이 적용되어 있어 QA팀과 개발팀이 최종 검증을 수행합니다. 이 환경은 실제 프로덕션과 동일한 구성을 가지나, 내부 용도로만 노출됩니다.


프로덕션 배포: main 브랜치에 새 커밋이 생기면, CI/CD 파이프라인이 프로덕션 배포를 트리거합니다. 그러나 main 병합은 보통 release 브랜치를 통해 이뤄지므로, 실제 배포는 운영팀이 Release PR을 main에 머지할 때 일어납니다. 배포 단계는 Staging과 유사하지만 production-latest 태그 혹은 버전 태그(v1.2.0)로 이미지를 생성하여 사용하고, 배포 대상 클러스터/서비스가 프로덕션용으로 지정됩니다.


승인 절차: 안정성을 위해 프로덕션 배포는 자동화하되 수동 승인 단계를 하나 둡니다. 즉 main에 머지 후, 파이프라인이 바로 진행되지 않고, 담당자가 CI 시스템에서 “Deploy to Production” 승인 버튼을 눌러야 배포가 진행됩니다. (긴급 핫픽스의 경우 바로 자동화 진행할 수도 있음)


무중단 배포: API 서버 등 백엔드 서비스는 AWS ECS의 Rolling update 설정으로 무중단 배포합니다. 즉, 새 버전 컨테이너를 올리고 Health-check 통과 후 구버전 컨테이너를 내리는 방식입니다. 배포 중에도 ALB가 새/구 인스턴스를 적절히 라우팅하여 서비스 중단 없이 트래픽을 처리합니다. 프론트엔드는 CloudFront에 파일을 업로드하면 자동으로 invalidation을 수행해 캐시를 갱신합니다. 사용자들은 새 페이지 로드시 최신 프론트를 받게 됩니다.


데이터베이스와 마이그레이션: 배포 시점에 DB 스키마 변경이 있으면, 먼저 백엔드 어플리케이션 배포 파이프라인에서 마이그레이션 스크립트(예: Prisma migrate, Flyway)를 실행합니다. 마이그레이션은 backwards-compatible하게 작성하여, 구버전 앱과 동시 구동 시 충돌 없도록 해야 합니다. 필요 시 DB 변경 → 앱 배포 순서를 조정하거나, feature-flag로 새 기능을 rollout합니다.


모니터링 & 로깅: 배포 후 AWS CloudWatch나 Datadog을 통해 **서버 메트릭(CPU, 메모리)**과 애플리케이션 로그를 모니터링합니다. 주요 API의 응답시간, 에러율, AI 호출 에러 등을 대시보드화하고, 문제가 감지되면 Slack 경고를 받도록 설정합니다. 배포 파이프라인에도 에러 캐치가 되어 실패 시 개발팀에게 즉시 알립니다.


릴리스 후 문제 발견 시 롤백 전략은, ECS의 이전 태그 이미지를 재배포하거나, Blue-Green 방식을 사용하는 경우 이전 그린 환경으로 트래픽을 전환하는 방식으로 수행합니다. 프론트엔드는 이전 버전 정적 파일을 별도 backup해두어 문제가 크면 신속히 복구 가능하게 합니다.


배포 빈도 및 윈도우: 초기 개발 단계에서는 **수시 배포(Continuous Deployment)**에 가깝게 운영하여, main에 머지된 작은 변경도 곧바로 프로덕션에 배포합니다. 다만 사용자 영향도가 큰 기능은 내부 플래그로 숨겨두고 충분히 테스트한 후 활성화(Canary Release)합니다. 배포는 업무 시간에 진행하되 (긴급 제외), 혹시 모를 장애 시 즉각 대응 인력이 대기합니다.


버전 넘버와 변경 로그(Changelog)를 유지하여, 각 배포에 어떤 개선/수정이 포함되었는지 기록합니다. 이는 운영과 고객지원에 활용됩니다.


보안 고려: 배포 파이프라인에 포함된 민감정보 (예: AWS 크리덴셜, API 키)는 CI의 시크릿 저장소에 보관되고, 로그에 노출되지 않게 마스킹 처리됩니다. 인프라 변경은 IaC(Terraform) 코드로 관리해 추적하고, 배포 과정에 수동 SSH나 SCP는 없도록 자동화와 권한 제어를 적용합니다.


요약하면, 배포 전략은 자동화된 도구를 최대한 활용한 신속/안정 배포를 지향합니다. 개발자는 코드에 집중하고, 배포는 파이프라인이 알아서 진행하므로 개발 사이클이 빨라집니다. 동시에 스테이징 검증, 단계적 출시, 모니터링/롤백 체계를 갖춤으로써 서비스 가용성을 지키는 것을 최우선으로 합니다.
17. 보안/권한 시스템 문서 (Security/Permission System)
스타트업쇼는 사용자 권한과 데이터 보안을 중요시하며, 다층적인 보안 전략을 구현합니다. 이 문서에서는 접근 권한 모델과 애플리케이션 보안 대책을 다룹니다.
① 권한(Role) 및 접근 제어:
역할 정의 (RBAC): 시스템에는 사전에 정의된 역할들이 있으며, 각 역할별 권한 범위는 다음과 같습니다:


FOUNDER (창업자/팀 리더): 스타트업을 생성한 사용자로, 해당 스타트업의 관리자 권한을 가집니다. 팀원 초대/삭제, 투자자 권한 승인/철회, 회사 프로필 편집, 민감 데이터 열람 등 모든 액션이 허용됩니다.


TEAM_MEMBER (팀원): 소속 스타트업의 일반 멤버로, 데이터 열람 및 과제 생성/편집 등 대부분 기능을 수행할 수 있으나, 투자자 권한 승인이나 회사 삭제 등의 관리자 기능은 제한됩니다. (※ 구현상 Role 필드는 FOUNDER와 MEMBER 두 값으로 구분, Founder=Owner로서 관리자 판정)


INVESTOR (투자자): 스타트업의 외부 사용자로, 기본적으로 어떤 스타트업에도 접근 권한이 없습니다. 특정 스타트업에 대해 접근 승인된 경우에만 해당 회사의 투자자용 데이터(대시보드, 업데이트, 데이터룸)를 읽기 전용으로 볼 수 있습니다. 편집 권한은 전혀 없고, 오직 열람과 댓글(있다면) 등 제한적 상호작용만 가능합니다.


ADMIN (플랫폼 관리자): 스타트업쇼 플랫폼을 운영/관리하는 내부직원 계정으로, 전체 데이터에 대한 읽기/쓰기 권한을 가집니다. 이들은 사용자 계정 차단, 콘텐츠 삭제, 시스템 설정 조정 등의 작업을 수행합니다. Admin 작업은 감사 로그에 특별히 기록됩니다.


권한에 따른 UI/기능 제한: 프론트엔드는 로그인한 사용자의 role과 권한 정보를 토대로 보여주기 단계에서부터 필터링을 합니다. 예를 들어 투자자는 팀 관리 메뉴를 아예 보지 못하고, 승인되지 않은 스타트업의 세부 페이지 접근을 시도하면 “권한 없음” 메시지를 보여줍니다. 그러나 신뢰할 수 없는 클라이언트 전제를 두고, 실제 데이터 요청 시 백엔드에서 2차 검증을 수행합니다.


백엔드 인증/인가 흐름: 모든 API 요청에는 JWT 액세스 토큰이 요구되며, 서버는 미들웨어에서 토큰을 검증해 req.user에 사용자 ID와 Role, 소속 Startup 목록 등을 담습니다. 각 핸들러는 이 정보를 활용해 세분화된 권한 체크를 합니다. 예:


GET /startups/{id}/... 호출 시: req.user의 role이 ADMIN이면 통과, 또는 role이 FOUNDER/TEAM_MEMBER이고 {id}와 req.user의 속한 Startup 중 일치하면 통과. role이 INVESTOR인 경우 InvestorAccess에서 (user, startup) 승인 여부를 조회하여 APPROVED 상태이면 통과, 아니면 403 반환.


POST /startups/{id}/invite 호출 시: 해당 {id}의 창업자(OWNER)인지 확인. 팀 멤버나 투자자가 이 엔드포인트를 호출하면 403.


이러한 체크 로직은 공통 모듈로 구현하여 중복을 피하고, 엔드포인트별 요구 권한을 선언적으로 지정 (예: @RequireRole('FOUNDER') 데코레이터 또는 정책 함수 사용)합니다.


InvestorAccess 관리: 투자자의 스타트업 데이터 접근은 InvestorAccess 테이블로 관리되고, APPROVED 상태가 되어야만 실제 데이터가 보입니다. 승인 전에는 API에서 404 혹은 빈 리스트처럼 처리하여 존재 여부도 숨깁니다 (보안상의 이유로 권한 없는 대상에 “정보 없음”으로 응답 처리). 승인 요청, 승인/거부 액션에는 모두 해당 테이블 상태 변화와 이력(누가 언제 승인했는지)을 남깁니다.


② 데이터 보안 및 보호:
인증 보안: 비밀번호는 BCrypt 등의 강력한 해시로 암호화 저장하며, 최소 8자, 대문자/숫자/특수문자 포함 등의 패스워드 강도 정책을 적용합니다. 로그인 시도 횟수 제한(예: 5회 실패 시 5분 락)을 두고, JWT 토큰에는 짧은 만료시간(예: 1시간)을 부여하며, 리프레시 토큰 전략으로 장기 세션을 관리합니다. 중요한 API 엔드포인트(비밀번호 변경 등)는 이중 인증(2FA)을 옵션으로 제공합니다.


통신 보안: 클라이언트와 서버 간 모든 트래픽은 HTTPS로 암호화됩니다. HTTP Strict Transport Security(HSTS) 헤더도 설정해 중간자 공격을 방지합니다. 또한 XSS/클릭재킹 방어를 위해 Content Security Policy(CSP), X-Frame-Options, X-XSS-Protection 등의 헤더를 설정하고, 쿠키에는 HttpOnly, Secure, SameSite=Lax 를 적용합니다.


입력 밸리데이션 & 방화벽: 모든 클라이언트 입력은 서버 측에서 재검증합니다. 예: API 요청 JSON 스키마를 Yup/JOI로 validate, 문자열 입력에 예상치 못한 script 태그나 SQL 구문 등이 없는지 검증. ORM 사용으로 SQL 인젝션 기본 방지하지만, 쿼리 작성 시에도 매개변수 바인딩을 철저히 사용합니다.


HTML 출력이 필요한 경우(예: 업데이트 내용)에는 **엔코딩(escape)**를 적용해 XSS를 방어합니다. Marked 같은 Markdown 파서 사용 시 안전 설정(스크립트 태그 제거 등)을 켜고, 사용자 제공 HTML은 Sanitizer를 거칩니다.


데이터 접근 제한: 한 사용자가 다른 사용자의 리소스를 임의로 접근하지 못하도록 Object-level access control을 구현했습니다. 예를 들어, URL의 StartupID나 TaskID 등을 신뢰하지 않고 반드시 해당 리소스의 소유자/소속과 req.user를 대조합니다. 투자자 A가 투자자 B에게만 허용된 스타트업ID를 요청하면 403이 반환됩니다.


데이터 암호화: DB에 저장된 민감 정보(예: 사용자 이메일, 투자 관련 민감 데이터 등)는 필요 시 암호화하여 저장하거나(특히 개인 식별 정보), 최소한 해싱/마스킹 처리합니다. 예: 비밀번호는 BCrypt 해시, 투자 금액 같은 필드는 평문으로 저장하더라도 API 응답시 일부 마스킹 처리. 또한 S3에 저장되는 파일(데이터룸 문서)은 S3 자체 암호화 설정(AES-256) + 서브폴더 접근제어로 외부에 노출되지 않게 합니다. 파일 다운로드는 일회용 서명 URL로만 가능하므로, 권한 검사 후 URL 발급, 짧은 만료(5분)로 제한합니다.


로그인 세션 관리: JWT를 사용하지만 추가로 중요 작업 시 재인증(예: 중요한 설정 변경시 비밀번호 재입력)을 요구하거나, 관리자 페이지 등 민감구역은 IP 제한을 둘 수 있습니다. 또한 로그아웃시 클라이언트는 JWT를 폐기하고, 서버에서도 Refresh 토큰 리스트에서 제거합니다. 토큰 탈취 위험을 줄이기 위해 Refresh 토큰은 DB에 해시로 보관하고, 이상 로그인(IP 변경 등) 감지 시 해당 세션 토큰을 강제 만료시킵니다.


감사 로그(Audit Logging): 보안상 중요한 행동(관리자 권한 행사, 투자자 데이터 열람 등)을 감사 로그 테이블에 기록합니다. 내용에는 언제, 어떤 계정이, 어떤 액션(예: “Investor X accessed Document Y of Startup Z”)을 했는지 저장되며, 이 로그는 관리자만 열람 가능합니다. 추후 분쟁이나 보안 사고 발생 시 역추적에 활용합니다.


③ 서버/인프라 보안:
서버 접근 통제: 배포 환경의 서버들은 SSH 접근을 최소화했습니다. CI/CD를 통한 자동 배포로 운영하며, 필요 시 bastion host를 거치고 MFA 인증된 계정만 접근 가능하게 Security Group을 구성합니다. 서버상 중요한 환경변수는 평문으로 두지 않고 AWS Systems Manager Parameter Store에서 암호화된 형태로 주입합니다.


의존성 보안: 정기적으로 npm audit, pip safety 등을 활용해 라이브러리 취약점을 점검하고, 심각 취약점이 발견되면 즉시 패치 버전으로 업그레이드합니다. 또한 서드파티 JS나 CSS CDN은 Subresource Integrity (SRI)를 사용하거나 자체 호스팅하여 공급망 공격을 예방합니다.


보안 테스트: OWASP Top 10에 대비한 취약점 점검을 실시합니다. 내부적으로 스캐너를 돌리고, 필요하면 외부 모의해킹(펜테스트)를 진행하여 발견된 취약점은 우선순위에 따라 대응합니다. AI 관련 보안(프롬프트 주입 공격 등)도 시나리오 테스트를 통해 대응책(출력 검열 등)을 마련합니다.


④ 권한 시나리오 예시 & 정책:
시나리오: 투자자 A는 접근 승인된 스타트업 X의 업데이트를 조회 가능하지만, 스타트업 Y는 승인되지 않아 접근 불가. → 구현: /startups/Y/updates 호출 시 InvestorAccess에 Y가 없으므로 403.


시나리오: 팀원 B는 자기 스타트업 X의 과제에 모두 접근 가능, 스타트업 X의 투자자 리스트도 조회 가능(단, 승인/거부 버튼은 창업자만). → 구현: B의 Role=TEAM_MEMBER, 권한: StartupID 매칭되면 과제 CRUD 허용, 단 InvestorAccess 승인 API는 RequireRole=FOUNDER로 제한.


시나리오: 창업자 C가 자기 스타트업을 삭제하려고 함. → 매우 위험한 작업으로, 확인 다이얼로그 + 재인증 절차 (비밀번호 입력) 요구. 백엔드도 DELETE /startup/X 호출 시 Role=FOUNDER인지 확인하고, 실제 삭제 전 관리자 승인 절차(운영팀 확인) 혹은 일정 유예(30일 비활성화 후 삭제) 정책을 적용.


시나리오: 관리자가 부적절한 콘텐츠(예: 스타트업 소개에 금지어 있음)를 발견하고 편집 또는 숨김 조치. → Admin 계정은 해당 스타트업 Description 필드 수정이 가능하며, 수정 내역을 History에 남겨둠. 또는 Admin이 투자자 업데이트를 숨길 경우 Update.Status를 ‘HIDDEN’으로 바꾸고, 스타트업팀에 통보.


⑤ 개인정보 및 컴플라이언스:
이용자의 개인정보(이름, 이메일 등)는 개인정보처리방침에 따라 최소한으로 수집/저장하며, 사용 목적 외에는 활용하지 않습니다. 법규 준수를 위해 회원 탈퇴 시 지체 없이 개인정보를 삭제(또는 기간을 두고 별도 보관 후 파기)합니다. 투자 관련 데이터는 민감정보일 수 있어 접근 권한 관리와 로그로 누가 열람했는지 기록합니다.


필요 시 서비스가 확장되면 ISO27001, GDPR 등 규범을 검토하여 준수 여부를 점검할 계획입니다.


요컨대, 보안/권한 시스템은 **최소 권한의 원칙(Principle of Least Privilege)**을 기반으로 설계되었습니다. 사용자는 자신의 권한 범위 내에서만 데이터를 볼/조작할 수 있으며, 시스템은 여러 단계의 검증과 방어 장치를 통해 데이터 유출이나 부정 액션을 차단합니다. 정기적인 보안 점검과 팀원 교육을 통해 보안 수준을 지속적으로 향상시켜, 신뢰할 수 있는 서비스를 제공하는 것이 목표입니다.
18. 온보딩 가이드 (개발자 & 사용자용)
온보딩 가이드는 새로운 개발자가 팀에 합류하거나 신규 사용자가 서비스를 사용할 때, 원활하게 적응하도록 돕는 절차와 자료를 정리한 문서입니다.
개발자 온보딩 가이드
신규 개발자가 스타트업쇼 프로젝트에 참여할 때 따라야 할 단계와 참고자료를 제공합니다:
개발 환경 설정:


리포지토리 접근: 신규 개발자는 GitHub 조직에 초대되어 리포지토리에 접근 권한을 얻습니다. 먼저 저장소를 로컬에 clone 합니다: git clone https://github.com/ourorg/glowus.git.


필수 도구 설치: Node.js LTS 버전, Python 3.9+, Docker Desktop, 그리고 패키지 매니저(Yarn 또는 npm) 등을 설치합니다. IDE로 VSCode를 권장하며, 팀의 .vscode/settings.json (들여쓰기 등 설정 공유)과 플러그인 목록(ESLint, Prettier, Docker, GitLens 등)을 안내합니다.


의존성 설치: 리포지토리 clone 후, 프론트엔드 디렉토리에서 npm install, 백엔드 디렉토리에서 npm install (또는 pip install -r requirements.txt if Python parts) 명령을 실행하여 필요한 라이브러리를 모두 받습니다.


환경 변수 설정: env.example 파일을 참고해 로컬 개발용 .env 파일을 작성합니다. 예를 들어, DB 연결 문자열(DEV_DATABASE_URL), API 키(OPENAI_API_KEY), JWT 시크릿(JWT_SECRET) 등을 본인 로컬에 맞게 설정합니다. 이 정보는 보안을 위해 별도 전달하며, 저장소에는 올라가 있지 않습니다.


DB 및 서비스 기동: Docker가 설치되어 있다면 docker-compose up -d로 로컬 DB(Postgres)와, 필요 서비스(예: Redis) 등을 띄웁니다. 또는 사전에 준비된 SQLite dev DB를 사용할 수도 있습니다. 개발용 데이터베이스 초기 스키마 작성을 위해 npm run migrate:dev 등을 실행하도록 안내합니다.


로컬 서버 실행: 백엔드의 경우 npm run dev (nodemon 사용)으로 서버를 기동하고, 프론트엔드는 npm start로 React 개발 서버(http://localhost:3000)를 띄웁니다. 모두 정상 기동되면 브라우저에서 http://localhost:3000에 접속하여 기본 페이지가 뜨는지 확인합니다.


코드 구조 및 컨벤션 학습:


프로젝트 구조 안내: 신규 개발자는 리포지토리의 README.md 및 본 가이드 문서를 통해 frontend/, backend/ 등의 디렉토리 구조와 각 부분 역할을 파악합니다. 예: backend/src/controllers, services, models…; frontend/src/components, features, store…


주요 기능 흐름: 예시로 “투자자 권한 승인” 기능의 코드 흐름을 추적해봅니다. UI 버튼 컴포넌트 -> Redux action -> API call -> 백엔드 Controller -> Service -> DB. 이러한 한 사이클을 팀 리더나 멘토 개발자가 설명해 줍니다. 이를 통해 신규 인력은 엔드투엔드 흐름을 이해합니다.


코딩 컨벤션 숙지: 본 문서의 코딩 컨벤션 섹션을 숙독하도록 합니다. 또한 린터/포매터 설정을 IDE에 적용하고, 샘플 코드 조각을 참고해 스타일을 맞춥니다. 팀 내에서 합의된 Git 커밋 메시지 규칙, 브랜치 전략도 다시 한번 강조하여, 실수로 main에 바로 push하지 않도록 주의시킵니다.


AI 도구 활용: 스타트업쇼 개발팀은 AI 코딩 도구 (예: GitHub Copilot 또는 Cursor AI 에디터)를 적극 활용합니다 . 신규 개발자에게 이러한 도구 사용법을 공유하고, 회사에서 정리한 유용한 프롬프트 예시를 안내합니다. 예: “함수 X에 대한 단위테스트 생성 프롬프트”. 다만, AI가 만든 코드라도 반드시 직접 이해하고 검토해야 함을 강조합니다 .


문서와 지식베이스: 사내 위키 또는 Notion에 축적된 설계 문서, 지난 회의 기록 등을 열람하도록 권합니다. 예: 아키텍처 다이어그램, 과거 결정 기록(ADR), 향후 로드맵 등. 또한 프로젝트 세팅, 배포 절차 등의 Runbook도 읽어두면 도움이 됩니다.


업무 수행 초기 단계:


멘토 지정: 신규 입사자에게는 기존 팀원 중 한 명이 멘토로 지정되어, 환경 설정부터 첫 과제 수행까지 도와줍니다. Code review 시 초반에는 멘토가 상세 피드백을 제공해 컨벤션 적응을 돕습니다.


첫 과제 선택: 보통 난이도 낮은 버그 수정이나 작은 기능 개선부터 맡깁니다. 예를 들어 “대시보드 날짜 표기 로케일 버그 수정” 같은 작업을 배정하고, 이를 통해 풀리퀘를 생성하고 머지하는 전체 프로세스를 경험하게 합니다.


코드 리뷰 및 학습: 멘토와 다른 개발자들이 PR 리뷰를 통해 개선점을 제안합니다. 신규 개발자는 리뷰 내용을 수용하며 팀의 코드 기준을 익힙니다. 필요시 오프라인으로 리뷰 내용을 함께 보며 리팩토링 세션을 갖기도 합니다.


개발 문화 적응:


데일리 스탠드업: 매일 아침 스크럼 미팅에 참석하여 진행 상황을 공유하고, 막힌 부분은 도움을 요청합니다. 이를 통해 업무 맥락과 팀 커뮤니케이션 방식에 익숙해집니다.


이슈 트래커 사용: Jira 또는 GitHub Issues를 활용해 작업을 관리하므로, 티켓 상태 변경, 커밋에 이슈번호 첨부 등 활용법을 익힙니다.


지속적인 피드백: 첫 몇 주간은 주간으로 멘토와 1:1 미팅을 가져 이해도/어려움 등을 점검하고, 개선 피드백을 줍니다. 또한 새로운 제안(예: 더 나은 도구)도 환영하니 편히 말하도록 독려합니다.


신규 개발자는 위 가이드를 따르면 약 1~2주 내에 본격적인 개발 업무에 투입될 수 있습니다. 환경 설정에서 배포 테스트까지 온보딩 미션을 완료하면, 실서비스 개발 사이클에 합류하게 됩니다. 회사는 온보딩 과정을 문서화/자동화하여, 인원 증가 시에도 효율적으로 진행할 계획입니다.
사용자 온보딩 가이드
새로운 사용자가 스타트업쇼 플랫폼에 가입하고 활용하는 과정을 단계별로 안내합니다. 사용자 유형별(스타트업팀 vs 투자자)로 구분하여 설명합니다.
스타트업 팀 (창업자/팀원) 온보딩:
회원가입 및 스타트업 생성: 스타트업쇼 메인 페이지에서 “무료로 시작하기”를 클릭하면 회원가입 페이지로 이동합니다. 사용자 유형에서 “스타트업 운영 팀”을 선택하고, 이름, 이메일, 비밀번호 등을 입력합니다. 가입 후, 스타트업 프로필 생성 단계로 넘어갑니다. 여기서 회사 이름, 산업, 회사 한줄 소개 등을 입력하고 프로필을 완성합니다.


Tip: 회사 한줄 소개는 투자자들이 보게 되므로 간결하고 임팩트 있게 작성하세요 (예: “AI로 재고 예측을 혁신하는 SaaS 솔루션”).


팀원 초대: 프로필 생성이 완료되면, 바로 팀원 초대 화면이 나타납니다. 동료의 이메일 주소를 입력하고 역할을 지정(공동창업자인 경우 ‘Owner’, 직원이면 ‘Member’)하여 초대장을 발송합니다. 초대받은 팀원은 이메일의 링크를 클릭해 가입 절차를 거치면 자동으로 해당 스타트업 팀에 합류합니다.


만약 지금 초대하지 않으려면: “나중에 하기”를 눌러 건너뛰고, 대시보드 우상단의 “팀 설정” 메뉴에서 언제든 초대할 수 있습니다.


대시보드 둘러보기: 처음 접속한 대시보드에 튜토리얼 모드가 활성화됩니다. 화면 요소에 하이라이트와 설명이 붙어, “여기가 당신의 KPI 현황판입니다”, “여기서 새 업무를 추가할 수 있습니다” 등 순차적으로 안내합니다. 5분 정도 투자하여 튜토리얼을 마치면 주요 기능의 위치와 사용법을 알 수 있습니다. 물론 “건너뛰기”도 가능하며, 나중에 도움말 센터에서 다시 볼 수 있습니다.


첫 번째 작업: 온보딩 과정 중, 시스템은 사용자가 초기 설정을 완료하도록 몇 가지 권장 액션을 제안합니다:


목표 지표 설정: KPI 위젯에 “설정 필요” 알림이 뜹니다. 클릭하여 월간 목표나 트랙킹할 지표(MRR, 사용자 수 등)를 설정합니다. 이는 차후 성과 추적과 투자자 보고에 활용됩니다.


과제 추가: “팀에 환영합니다! 첫 번째 과제를 추가해보세요” 라는 안내와 함께 과제 생성 버튼을 가리킵니다. 예시로 “제품 출시 일정 잡기” 등 샘플 과제를 하나 작성해보도록 유도합니다. 작성하면 칸반보드에 나타나고 알림이 팀에 공유됩니다.


투자자 업데이트 시작: 아직 투자자가 없더라도, “가상 투자자에게 월간 업데이트를 연습 작성해보세요”라는 메뉴가 있습니다. 이를 클릭하면 업데이트 템플릿이 열리고, AI가 제공한 예시 데이터로 보고서를 만들어볼 수 있습니다. 작성 완료 후 실제 전송은 안 되지만, 양식을 익히는 데 도움이 됩니다.


AI 어시스턴트 활용: 화면 우하단 챗봇 아이콘이 반짝이며 “무엇이든 물어보세요!“라고 안내합니다. 클릭하면 예시 질문들이 나타납니다 (예: “어떤 기능을 먼저 사용해야 할지 알려줘”). 사용자는 “안녕, 처음인데 뭘 하면 될까?” 같은 자연어로 물어볼 수 있습니다. AI 어시스턴트는 온보딩 FAQ를 기반으로 답변합니다 (예: “팀원을 초대하고, KPI를 설정해보세요…”). 이렇게 사용자들은 모르는 것이 있으면 메뉴얼을 찾지 않고 물어볼 수 있습니다.


Note: AI가 회사 고유 정보에 접근하려면 권한이 필요합니다. 처음엔 일반 가이드 위주로 답하고, 더 상세한 회사관련 질문(예: “이번달 매출은?”)에는 “아직 데이터가 없어요, KPI를 설정해주세요”라고 안내합니다.


리소스 & 도움말: 화면 상단 메뉴에 “도움말 센터” 링크가 있어, 사용자는 언제든 FAQ, 가이드 영상을 볼 수 있습니다. 예를 들어 “투자자 초대는 어떻게 하나요?” 질문을 검색하면 단계별 문서와 스크린샷을 볼 수 있습니다. 또한 채팅 지원이 가능하도록, 업무시간에는 채널톡/인터콤으로 운영팀과 연결도 지원합니다.


투자자 사용자 온보딩:
회원가입 (투자자용): 투자자는 가입 시 “투자자/VC” 유형을 선택합니다. 이름, 이메일 외에 추가로 소속 펀드명, 직책, 관심 투자 분야 등을 입력하도록 안내합니다. 이 정보는 추후 매칭 알고리즘과 스타트업 측 프로필 노출에 활용됩니다 (투자자가 관심 분야를 공개 동의하면, 스타트업이 리스트에서 볼 수 있음).


프로필 세팅: 로그인 후 최초 투자자 대시보드에 오면 “내 투자자 프로필을 완성하세요” 알림이 상단에 나타납니다. 클릭 시 프로필 페이지로 이동하여, 자기소개, LinkedIn 링크, 주요 포트폴리오(투자 사례) 등을 추가할 수 있습니다. 이러한 프로필은 스타트업이 투자자 접근 요청을 받았을 때 확인 자료로 보여지므로, 상세히 작성하도록 권장합니다.


서비스 기능 안내: 투자자 대시보드에도 튜토리얼이 있습니다. “추천 스타트업 목록”, “검색 바”, “받은 초대/요청” 섹션 등을 하이라이트하여 설명합니다. 예: “이곳에서 관심 분야의 스타트업을 추천받습니다”, “여기에서 특정 스타트업을 이름으로 검색할 수 있습니다”. 투자자는 스타트업팀보다는 단순한 인터페이스지만, 권한 관련 개념을 이해하도록 돕습니다 (예: “회색 자물쇠 아이콘이 있는 스타트업은 접근 요청을 해야 상세 내용을 볼 수 있습니다”).


관심 설정: 투자자가 서비스에 처음 왔을 때, 관심사 태그 설정 모달이 뜹니다. AI 추천을 고도화하기 위해, 선호 산업(핀테크, 헬스케어 등), 선호 투자 단계(Seed, Series A 등), 희망 투자 금액 범위 등을 체크리스트로 선택하게 합니다. 이는 매칭에 활용되고, 이후에도 설정 메뉴에서 수정 가능합니다.


스타트업 탐색: 투자자는 바로 추천 리스트를 확인하거나, 검색 기능을 이용해 스타트업을 찾아볼 수 있습니다. 예를 들어 추천 리스트에 “ABC Tech (핀테크, 시드단계)“가 보이면 클릭해 상세 프로필(공개 정보만)을 봅니다. 그 자리에서 “열람 요청”을 보내는 방법을 UI 툴팁으로 안내합니다 (“이 버튼을 누르면 해당 스타트업에게 데이터 열람을 신청합니다”).


만약 투자자가 이미 아는 스타트업을 찾고 싶다면, 상단 검색바에 이름을 입력합니다. 만약 검색이 안 되면 그 스타트업이 아직 우리 플랫폼에 없을 수 있으므로, “없나요? 추천하여 초대하세요” 옵션을 제공해, 투자자가 스타트업을 플랫폼에 초대하도록 유도합니다.


투자자용 AI 어시스턴트: 투자자도 챗봇을 통해 도움을 받을 수 있습니다. 예: “어떤 스타트업을 보면 좋을까?“라고 물으면, AI는 투자자의 프로필을 참고해 관심 분야 상위 추천 스타트업을 소개하거나, 플랫폼 이용 방법 (예: “산업 필터를 활용해보세요”)을 안내합니다. 또한 투자자가 어떤 용어(예: “MRR”)를 모를 경우 물어보면 AI가 설명합니다. 이는 투자자가 서비스뿐만 아니라 스타트업 지식을 습득하는데도 도움을 줍니다.


알림 이해: 투자자에게 중요한 온보딩 요소는 알림입니다. 만약 스타트업이 투자자를 초대했다면, 이메일과 앱 알림으로 “OO 스타트업이 데이터를 공유했습니다”가 옵니다. 초대 받은 경우, 대시보드 “초대받은 스타트업” 영역에서 해당 스타트업을 승인(열람 시작)하거나 거절할 수 있습니다. 이러한 프로세스를 별도 팝업 튜토리얼로 설명합니다. (예: “창업자가 투자 열람을 초대하면 여기 표시됩니다. 수락하면 해당 스타트업 탭이 열립니다.”)


지속적인 케어: 가입 후 초기 며칠 동안, 투자자가 아무 활동이 없으면, 제품 교육 이메일 시리즈가 전송됩니다. 첫째 날에는 “시작하는 방법” 가이드, 셋째 날에는 “추천 기능 소개”, 일주일 후에는 “피드백 요청” 등의 메일이 가서 유입 사용자의 정착을 높입니다. 만약 투자자가 onboarding 중 이탈하면, CS팀이 별도로 연락하여 도움을 제안하기도 합니다 (주로 핵심 VIP 대상).


FAQ 및 문제 대응:
사용자가 가입 인증 메일을 못 받았을 경우: 스팸함 확인을 안내하고, 대시보드에 재전송 버튼을 제공합니다.


팀원 초대 링크가 만료됐을 경우: 초대한 창업자가 팀 설정에서 다시 초대하거나, 만료 기한(예: 7일)을 안내 후 새 링크 발급합니다.


투자자가 권한 요청을 했는데 답이 늦는 경우: 일정 기간(예: 3일) 지나도 미승인시 리마인드 메일을 스타트업팀에 보내고, 투자자에겐 “아직 대기 중” 상태를 표시합니다. 필요시 스타트업쇼 운영팀이 팔로업하여 양쪽이 커뮤니케이션할 수 있게 돕습니다.


이와 같은 온보딩 가이드는 서비스 내 튜토리얼, 도움말 센터 글, 그리고 CS 대응 스크립트 등으로 다양하게 구현되어 있습니다. 목표는 신규 사용자가 최소한의 노력으로 서비스를 이해하고 가치있는 행동(팀원 초대, 데이터 공유, 투자 요청 등)을 빠르게 수행하도록 하는 것입니다. 개발팀도 사용자 온보딩 데이터(걸린 시간, 포기 지점 등)를 분석하여, UX를 지속 개선하고 있습니다.
19. 투자자 열람 시스템 및 권한 흐름 (Investor Viewing System & Permission Flow)
스타트업쇼의 투자자 열람 시스템은 스타트업이 자신의 민감한 데이터를 투자자와 공유할 때 적용되는 권한 제어와 워크플로우를 의미합니다. 이 섹션에서는 투자자가 스타트업 정보를 요청 → 승인 → 열람 → 철회하는 전체 흐름과 내부 로직을 상세히 설명합니다.
권한 상태 및 정의:
InvestorAccess 테이블을 통한 투자자-스타트업 관계는 앞서 정의했듯 PENDING, APPROVED, DENIED, REVOKED 상태로 구분됩니다.


PENDING: 투자자가 열람을 요청했으나 아직 스타트업이 승인하지 않은 대기 상태.


APPROVED: 스타트업 관리자가 투자자의 열람을 승인한 상태. 투자자는 해당 스타트업의 비공개 정보에 접근 가능.


DENIED: 스타트업 관리자가 요청을 거부한 상태. 투자자는 접근 불가하며, 재요청하려면 일정 기간(예: 30일) 후 가능하도록 제한하거나, 아예 해당 스타트업에 재요청 불가 정책(협의사항)을 둘 수 있습니다.


REVOKED: 한때 승인되었으나, 나중에 창업자가 권한을 철회한 상태. 투자자는 더 이상 접근이 차단되고, 데이터룸 파일 다운로드 등도 불가.


흐름 1: 투자자의 열람 요청 프로세스
요청 발행: 투자자가 UI에서 “접근 요청” (또는 “투자 제안 요청”) 버튼을 누르면, 클라이언트는 POST /startups/{id}/request-access API를 호출합니다. 서버는 InvestorAccess 테이블에 해당 (investor, startup) 조합의 레코드를 생성합니다 (이미 존재한다면 상태만 업데이트하거나, PENDING 중복 생성 방지). 생성 시 Status=PENDING, RequestedAt=now(). 이때 투자자가 간단 메시지(소개나 요청 이유)를 첨부할 수 있게 설계되어 있다면 함께 저장합니다 (ex: “투자 검토를 위해 열람을 요청드립니다. -투자자A”).


알림 전송: 서버는 스타트업의 Owner/관리자들에게 실시간 알림을 생성합니다. 웹소켓/푸시를 통해 대시보드 알림에 “투자자 {Name} 님이 귀하의 스타트업 자료 열람을 요청했습니다” 메시지가 뜹니다. 동시에 서버는 이메일을 트리거하여, 창업자 이메일로도 동일한 내용의 알림을 보냅니다 (모바일 푸시도 있다면 발송).


UI 표시(스타트업 측): 창업자가 웹에 접속해 있다면, 알림을 클릭하여 권한 관리 화면을 엽니다. 권한 관리 UI에는 PENDING 요청 목록이 표시됩니다. 각 항목에는 투자자 이름, 소속, 프로필 정보, 그리고 요청 메시지가 보입니다. 또한 “승인”과 “거절” 버튼이 함께 표시됩니다. 만약 여러 투자자가 동시에 요청한 경우 리스트업되고, 창업자는 하나씩 검토합니다.


(UI 세부: 투자자 프로필의 더보기 버튼을 눌러 상세 정보를 볼 수 있게 하거나, 투자자가 과거에 이 스타트업에 대한 접근이 있었는지도 표기하면 유용합니다.)


중복 요청 처리: 만약 동일 투자자가 이미 PENDING 상태인데 다시 요청을 시도하면, 서버는 “이미 대기 중” 에러를 주거나, 클라이언트에서 버튼을 비활성화합니다. APPROVED 상태에서 재요청은 불필요하고, REVOKED/DENIED 상태에서 재요청은 정책에 따라 허용 시 새로운 PENDING 생성할 수 있습니다 (우리 정책은 거부 후 일정 기간 재시도 금지일 수 있음). 이런 시나리오는 UX에 명시되어야 혼란이 없습니다.


흐름 2: 스타트업 관리자의 승인/거절 프로세스
승인 처리: 창업자가 권한 요청 목록에서 특정 투자자를 승인하기로 결정하면 “승인” 버튼을 클릭합니다. 클라이언트는 PUT /startups/{id}/access-requests/{investorId} (혹은 PATCH) API를 호출하여 Status를 APPROVED로 업데이트합니다. 서버 로직:


해당 InvestorAccess 레코드 찾기 -> Status = APPROVED, DecidedAt = now(), ApprovedBy = currentUserId.


데이터베이스 트랜잭션 커밋 후, 투자자에게 열람 권한이 생겼으므로, 이후 권한 체크 시 이 investor-startup에 대해 통과되도록 합니다.


승인에 따른 이벤트 처리: 승인 시 투자자에게 즉각 알림을 보냅니다 (”{스타트업명}에서 귀하의 열람 요청을 승인했습니다. 지금 데이터를 확인해보세요.”). 이메일에도 승인 통지와 바로가기 링크를 전송합니다.


추가로, 이 스타트업이 투자자 추천 리스트나 검색에서 “요청 가능”에서 “접근 중” 상태로 UI가 변해야 하므로, 클라이언트 데이터도 업데이트합니다. (예: 투자자 측 목록에서 자물쇠 아이콘이 풀리고, 바로 대시보드로 이동 가능하게 처리)


권한 승인 기록은 감사 로그에도 남깁니다 (who/when).


거절 처리: 창업자가 “거절” 버튼을 누르면, API를 통해 Status = DENIED로 설정하고 DecidedAt 기록합니다.


이때 투자자에게 알림 (”{스타트업명}이 열람 요청을 거절했습니다.”)을 보내며, 거절 사유를 입력 받았다면 함께 전달합니다. 투자자는 대시보드의 해당 스타트업 카드에서 “거절됨” 표시를 보게 됩니다.


거절된 요청은 UI에서 목록에서 사라지거나 “거절됨” 섹션으로 이동합니다. 투자자가 다시 요청하려면 별도 UI (활성화되어 있지 않고 설명 텍스트 “요청이 거절되었습니다”만 표시)로 제약을 줍니다.


거절도 감사 로그에 기록해둡니다.


부분 승인 (기능적 고려): 경우에 따라 스타트업이 부분적인 데이터만 공유하기 원할 수 있습니다. 현재 시스템에서는 APPROVED 시 전체 데이터룸/업데이트 접근을 허용하지만, 향후 “문서별 권한 설정” 등이 추가된다면, 승인 단계에서 공유 범위를 선택하게 할 수 있습니다. (예: 재무데이터 제외 등). 그러면 InvestorAccess에 권한 범위 필드가 필요합니다. 현재 버전에서는 범위 옵션 없이 일괄 허용으로 가정합니다.


흐름 3: 투자자의 열람 및 사용
투자자 측 접근: 투자자가 승인 통지를 받으면, 웹에서 해당 스타트업 프로필을 열 수 있게 됩니다. 투자자 대시보드에 “열람 중인 스타트업” 리스트에 추가되고, 클릭 시 스타트업의 **대시보드 뷰(투자자용)**가 뜹니다. 여기에는 공유된 지표, 팀 소개, 투자자용 코멘트란 등이 있습니다.


데이터룸 탭: 투자자는 문서 리스트를 보고 다운로드할 수 있습니다. 다운로드 링크 클릭 시 서버에 JWT와 함께 요청 → 서버는 InvestorAccess APPROVED 확인 후 S3 pre-signed URL 발급 → 투자자가 파일 다운로드.


업데이트 탭: 과거 모든 발행된 투자자 업데이트를 읽을 수 있습니다. 업데이트 내용에 질문이 있으면 댓글로 달 수 있고, 창업팀은 이를 확인해 답글을 남길 수 있습니다 (댓글 기능이 켜진 경우).


리얼타임 알림: 해당 스타트업이 새로운 업데이트를 게시하면, 이 투자자도 실시간 알림/메일을 받습니다. 또한 스타트업이 허용을 철회하면, 투자자에게 “열람 권한이 철회되었다”는 통보를 즉시 보내줍니다.


데이터 사용 & 보호: 투자자는 열람한 정보를 외부로 유출하지 않아야 하며, 이용 약관에 이에 대한 동의 조항이 포함됩니다. 시스템적으로는 투자자가 본 화면을 캡처하거나 내보내는 것을 완전히 막을 순 없지만, PDF 워터마크 (예: 다운로드 문서에 투자자 이메일 워터마크 삽입) 등의 조치를 통해 유출시 추적 가능하도록 합니다.


데이터룸 파일을 다운로드하면, 기록에 남아 창업자가 “누가 언제 어떤 파일을 열었는지” 볼 수 있게 UI를 제공할 예정입니다. 이를 통해 창업자가 투자자의 관심도를 파악하거나, 의심스러운 활동을 감지할 수 있습니다.


커뮤니케이션: 플랫폼 내에 투자자와 창업자 간 메시징 기능을 고려할 수 있습니다. 현재 MVP 단계에선 댓글(업데이트에 대한 질문/답변) 정도지만, 향후 1:1 채팅이나 Q&A 섹션을 두어, 투자자가 궁금한 점을 물으면 창업자가 답하고 그 내용이 InvestorAccess 범위 내에 공유되는 형태로 발전 가능합니다. 권한 흐름상, APPROVED 된 투자자만 참여할 수 있는 private Q&A 입니다.


흐름 4: 권한 철회 및 만료
권한 철회 (스타트업 측): 창업자는 투자자 열람을 언제든지 철회할 수 있습니다. 권한 관리 페이지에서 현재 APPROVED된 투자자 리스트가 보이며, 각자에 “철회” (Revoke) 버튼이 있습니다. 누르면 확인 다이얼로그(“정말 {투자자명}의 접근을 철회하시겠습니까?”) 후 진행됩니다. 서버에서 해당 InvestorAccess.Status를 REVOKED로 업데이트하고 DecidedAt 갱신, 그리고:


투자자에게 알림/메일: “스타트업 {Name}이 귀하의 열람 권한을 철회했습니다. 더 이상 정보를 볼 수 없습니다.” 안내.


투자자 UI 업데이트: 해당 스타트업이 리스트에서 사라지거나 비활성 표시됩니다. 클릭 시 “접근 권한 없음” 메시지가 보입니다.


데이터 접근 차단: 서버는 InvestorAccess 조회 시 REVOKED이면 권한 없는 것과 동일하게 처리하도록 하여, API 차단. 이미 열려있는 웹페이지에서 추가 행동을 하면 API 에러를 받아 “권한이 철회되었습니다, 이 페이지를 닫으세요” 같은 모달을 띄우게 할 수 있습니다.


권한 만료 (정책): 권한을 영구히 주는 것이 부담이라면, 시스템적으로 만료 기간을 둘 수 있습니다. 예: APPROVED 후 60일 지나면 자동 REVOKE (투자자와 합의하에 연장 가능). 현재는 이런 기능은 없지만, 향후 옵션으로 고려 가능합니다. 구현시 InvestorAccess에 ExpiryDate 필드 추가, 주기적 크론으로 만료 도래시 상태 변경.


권한 요청 취소 (투자자 측): 투자자가 요청 후 마음이 바뀌면, 스타트업이 결정하기 전에 “요청 취소”를 할 수 있습니다. UI에서 PENDING 상태일 때 “취소” 버튼을 제공하고, 누르면 서버에서 해당 레코드 삭제 또는 별도 상태(취소됨)로 표시합니다. 이 경우 창업자 측 목록에서 제거되고, 알림도 무효화합니다. (현재 MVP에서는 취소기능은 필수는 아니지만 UX적으로 고려).


다른 시나리오:


투자자 계정 탈퇴: 투자자가 플랫폼을 탈퇴하면, 관련 모든 InvestorAccess 레코드도 함께 삭제하거나 무효화합니다. 창업자 측엔 해당 투자자 이름 옆에 “(탈퇴)” 표시하거나 목록 제거. (Implement: DB cascading or on delete trigger)


스타트업 계정 탈퇴: 스타트업이 서비스를 떠날 경우, 그와 연관된 모든 투자자 접근 권한은 의미 없어지므로 모두 삭제/만료 처리하고 투자자들에게도 알림(“스타트업 {Name}은 더 이상 플랫폼을 사용하지 않습니다”)을 줍니다.


UI/UX 고려:
권한 상태별 아이콘과 색상을 명확히 구분하여 한눈에 파악 가능하게 합니다. 예: PENDING=노란 시계 아이콘, APPROVED=녹색 체크, DENIED/REVOKED=회색/빨간 X.


스타트업 프로필에 투자자가 승인된 경우 “열람 중인 투자자 {N}명” 정보를 표기하여, 창업자가 얼마나 공유하고 있는지 인지하도록 합니다. 클릭하면 권한 관리로 바로 이동.


활동 로그: 권한 흐름의 주요 이벤트(요청/승인/철회)는 스타트업 활동 로그에도 남겨, 팀원들도 누가 접근하게 되었는지 알 수 있게 투명성 제공합니다.


안전장치: 혹시 잘못 승인/거절을 방지하려면, 승인/거절/철회 버튼 누를 때 한번 더 “이 작업은 되돌릴 수 없습니다” 경고를 표시합니다 (특히 거절/철회 시 관계에 영향 줄 수 있으므로).


내부 구현 정리:
API 계층에서 InvestorAccess를 조작하는 모든 엔드포인트에는 앞서 정의한 권한 체크를 삽입합니다. 투자자 본인이 자신의 요청 상태 조회나 취소만 가능, 스타트업 팀은 자기 스타트업 건만 관리 가능.


서비스 계층에서 승인/거절 시, Atomic하게 관련 작업(알림 생성, 이메일 전송 enqueue 등)을 처리합니다. 실패 시 롤백 계획: 예를 들어 이메일 전송 실패해도 트랜잭션은 유지 (사후 재시도로 해결), 그러나 DB 업데이트 실패 시 전체 실패 등.


시스템 테이블 (InvestorAccess) 레코드 수가 많아질 수 있으므로, (investorId, status)나 (startupId, status) 인덱스 최적화로 승인 대기 목록 조회를 빠르게 합니다. 또한 승인이 완료된 오래된 기록은 아카이빙하거나 investorId별 최신만 캐시하여 속도 개선을 고려합니다.


이러한 투자자 열람 권한 흐름은 스타트업이 자율적으로 투자자에게 정보를 제어하여 공유하게 함으로써, 신뢰 기반의 관계를 구축하도록 설계되었습니다. 동시에, 시스템은 그 과정을 투명하고 안전하게 관리하여, 정보 유출 위험 없이 투자 검토 절차를 지원합니다.
20. 스타트업 ↔ VC 매칭 로직 구조 (Startup ↔ VC Matching Logic)
스타트업쇼의 매칭 로직은 스타트업과 벤처캐피탈(투자자) 간에 효과적인 연결을 돕기 위해 설계된 추천 알고리즘입니다. 이 구조는 양측의 프로필 정보를 분석하여 상호 관심과 적합도가 높은 쌍을 찾아 제안합니다. 아래에 매칭 로직의 핵심 요소와 데이터 흐름을 설명합니다:
입력 데이터:
스타트업 프로필 데이터:


산업 분야: 예: 핀테크, 바이오테크, SaaS 등. (다중 선택 가능)


회사 단계: 아이디어/프로토타입, 시드, Series A, B… (자금 조달 단계 또는 제품 성숙도)


위치: 국가/도시 (투자자 선호 지역과 비교 용)


자금 요청 규모: 현재 라운드에서 원하는 투자금 범위 (예: $500k~$1M)


기타: 기술스택/특허 등 특이사항 (현재 알고리즘에서는 주로 매칭에 사용 안 하지만 참고)


VC/투자자 프로필 데이터:


선호 산업/분야: 투자하고자 하는 업종 리스트.


선호 투자 단계: Seed/Series A 등.


평균 투자 규모: 1회 투자 금액 범위, 펀드 규모.


포트폴리오: 과거 투자한 스타트업들의 분야와 특성 (이로부터 선호를 역추론 가능).


지역 선호: 국내/해외, 특정 지역 집중 여부.


기타 선호: 예: ESG 투자 관심, 기술/IP, 창업자 경력 선호 등 (자유 텍스트를 NLP로 처리 고려 가능).


이러한 데이터를 정형화하여, 매칭 알고리즘의 입력으로 사용합니다.
기본 매칭 알고리즘: (Rule-based Scoring)
필터링 단계: 우선 양측 프로필에서 필수 조건을 만족하는 쌍만 고려합니다. 필터 조건:


투자자의 선호 산업 리스트와 스타트업 산업이 적어도 하나 겹치는지 (없으면 matching score=0).


투자자의 선호 단계와 스타트업 현재 단계가 일치하는지 (예: Seed 전문 VC에게 Series C 스타트업은 제외).


투자자의 지역 선호와 스타트업 위치가 맞는지 (혹은 글로벌 투자자인 경우 모두 통과).


투자 금액: 스타트업 요청액이 투자자의 평균 투자 범위 내인지 (너무 크거나 작으면 낮은 우선순위).


이 필터를 통과하지 못하면 score를 계산하지 않고 제외. 통과한 후보들에 대해서 다음 단계로.


점수 산정 단계: 여러 요인에 가중치를 부여해 매칭 점수(0~100)로 환산합니다:


산업 적합도 (40점): 투자자 선호 산업 중 스타트업 산업이 얼마나 밀접한지. 완벽히 일치 = 40, 유사 분야(태그 기반 유사도) = 20~30, 아예 다른 분야 = 0.


단계 적합도 (25점): 정확히 일치 = 25, 한 단계 차이(예: 투자자는 Seed까지, 스타트업은 Pre-Series A) = 15, 그 이상 차이 = 0. (단계는 Yes/No보단 약간의 탄력성 부여)


투자 규모 적합도 (15점): 스타트업 요청액이 투자자 평균보다 작으면 15 (투자자가 여유), 약간 크지만 펀드 여력으로 가능하면 10, 두 배 이상 크면 0 (투자 곤란).


과거 투자 유사성 (10점): 투자자의 기존 포트폴리오 산업/모델과 스타트업이 유사하면 10, 아니면 0. (이는 경험상 관심 영역을 의미함)


지역 선호 (10점): 같은 지역 = 10, 인접/관심시장 = 5, 전혀 무관 = 0.


(필요시) 창업팀 경력, ESG 등 기타 요소를 점수화할 수도 있음 (현재는 제외).


이렇게 합산한 점수가 높을수록 매칭 우선순위가 높습니다. 예를 들어 90점 이상은 “강력 추천”, 7089 “추천”, 5069 “보통” 등으로 등급을 둘 수 있습니다.


정렬 및 컷오프: 각 스타트업-투자자 쌍에 대해 score 계산 후,


스타트업 관점 추천: 해당 스타트업에 대해 top N (예: 5명)의 투자자를 점수 순으로 추천 목록 생성.


투자자 관점 추천: 해당 투자자에게 top N개의 스타트업을 추천.


N의 값은 UI에 보여줄 항목 수와, 점수 임계값을 고려하여 정합니다 (예: 5개 또는 점수>=60인 모든).


너무 낮은 점수(예: <40)는 추천하지 않음. 추천 없으면 “조건에 부합하는 추천이 현재 없습니다” 안내.


동점/근소한 차이 처리: 점수가 동일하거나 근소할 경우 추가 tie-breaker:


최신 가입/업데이트된 순으로 우선 (새로운 정보일수록 추천 상위에 노출, 신선도 개념).


혹은 단순 랜덤셔플 요소 조금 넣어 매번 약간 순서 변화를 주어 다양한 매칭 시도.


고급 매칭 알고리즘 (향후 개선):
머신러닝 접근: 데이터 축적 후에는 Matrix Factorization이나 Graph-based 추천 알고리즘 도입을 검토합니다. 예: 스타트업-투자자 bipartite graph 만들고, 과거 연결/투자 사례 학습하여 link prediction (collaborative filtering) 적용.


임베딩 유사도: 스타트업 소개글과 투자자 투자철학(소개글)을 문장 임베딩하여 코사인 유사도 측정. 예를 들어 투자자의 소개에 “impact investing”이 있고 스타트업이 “사회적 가치” 강조하면 높은 점수. 이런 텍스트 기반 유사도를 점수에 가미하면 rule-based의 한계를 보완합니다.


피드백 루프: 사용자가 추천에 대해 취한 행동 (접근 요청 보냈다=긍정 신호, “관심없음” 눌렀다=부정 신호, 아무 액션 없다=중립)을 수집해 점수를 동적으로 조정합니다. ML로 학습하거나, 간단히 “관심없음” 투자자는 차후 추천 제외 리스트에 추가하는 등의 collaborative filtering 적용.


매칭 실행 구조:
매칭 계산은 오프라인 배치와 실시간 쿼리 두 가지가 혼합되어 구현됩니다:


정기 배치: 시스템이 매일 밤 모든 스타트업에 대해 추천 투자자 목록을 계산해 DB에 캐싱해 놓습니다 (Recommendation table). 그리고 투자자에 대해서도 추천 스타트업을 캐싱. 이렇게 함으로써 사용자가 접속할 때 빠르게 보여줄 수 있습니다. (스케일이 커지면 완전한 all-to-all 연산이 비쌀 수 있으나, 필터링을 적용해 후보 축소 가능. 예: 단계/산업 매칭 1차 필터 후 점수화)


실시간 업데이트: 사용자가 자신의 프로필을 바꾸거나, 새로운 스타트업/투자자가 가입하면 관련 캐시를 갱신합니다. 예: 새로운 스타트업이 “핀테크/Seed”라면 핀테크+Seed 선호 VC들을 대상으로 즉각 score 계산해 해당 VC들의 추천 리스트에 반영. 혹은 on-demand로 사용자가 추천 페이지 열 때 그 시점 계산할 수도 있습니다. 현재 사용자 수 적을 땐 on-demand도 가능.


기술 구현은 백엔드에서 서비스 레이어로 처리하거나, 별도 추천 마이크로서비스를 둘 수 있습니다. 간단 rule 기준이므로 현재는 DB 쿼리 + 코드 연산으로 처리. (예: SELECT investor_id, ... FROM investors WHERE industry @> {startup.industry} ... 등으로 1차 필터 후, 앱서버에서 점수 계산).


데이터 저장: Recommendation 테이블 (investor_id, recommended_startup_ids[], updated_at) 또는 반대로 StartupRecommendations (startup_id, investor_ids[], scores, updated_at) 형식으로 캐싱. 또는 JSON 컬럼으로 점수까지 함께 저장. 이 캐시 데이터는 UI에서 활용되고, 사용자가 refresh하거나 24시간마다 갱신.


UI 표시:


스타트업 팀 화면: “추천 투자자 목록” 섹션에서 각 투자자 카드에 이름, 소속, 점수 또는 “매우 잘 맞음/보통” 등의 라벨, 그리고 “요청 보내기” 버튼.


투자자 화면: “추천 스타트업” 섹션 유사하게 표시, “관심 없음” 버튼 제공.


설명: 각 추천 옆에 i 아이콘을 두어, 클릭 시 “왜 이 추천이 떴는지” 간략 설명 . 예: “선호 산업(핀테크)이 일치합니다” or “귀사의 단계(시드)에 투자 경험이 풍부합니다”. 이 설명은 앞서 Prompt Library에서 “매칭 추천 설명 프롬프트”로 AI가 생성할 수도 있지만, 우선 rule 기반 사유를 문자열로 작성합니다. 이는 추천 수용도를 높이는 UX 요소입니다.


매칭 알고리즘 검증 및 개선:
정기적으로 정확도 평가를 합니다. 추천이 실제 연결(Approach)로 이어진 비율, 또는 사용자가 수동으로 찾은 매칭 대비 얼마나 도움되었는지 분석합니다. 피드백을 바탕으로 가중치를 조정 (예: 산업보다 단계가 더 중요하면 가중치 변경).


A/B 테스트: 새로운 ML모델 기반 추천 vs 기존 rule-based를 일부 사용자 그룹에 나눠서 성능 비교 (장기적 계획).


콜드스타트 문제: 신규 투자자나 스타트업은 데이터 부족으로 추천 품질 낮을 수 있으므로, “신규 가입자 특별 추천” 로직으로 우선순위 노출하거나, 기본 산업/단계 매칭만으로라도 추천 제공. (또는 운영자가 수동 추천 보완)


보안/프라이버시: 매칭은 기본적으로 상호 공개 정보를 기반으로 합니다. 민감정보를 사용하지 않고, 투자자가 원하지 않는 경우 익명 추천도 가능하도록 설정할 수 있습니다 (예: 투자자가 프로필 비공개 선택시, 스타트업에게는 “알 수 없음 투자자”로 표시하거나 추천 제외). 그러나 플랫폼의 가치가 프로필 공개에 있으므로 기본은 공개.
확장성: 스타트업 수 M, 투자자 수 N일 때 최악 MxN 비교이나, 필터로 많이 줄이고 인덱스 활용하면 수천까지 문제없습니다. 향후 규모 커지면, 산업/단계별 bucketting으로 제한적인 비교, 또는 vector similarity search(embedding)로 바꿔 확장 가능합니다 (예: Pinecone으로 투자자 임베딩 vs 스타트업 임베딩 K-NN 검색).
결론적으로, 매칭 로직 구조는 다중 기준 점수화를 중심으로 하며, 현재는 규칙 기반으로 명시적 요인을 활용하지만, 데이터 축적과 함께 AI/ML 기법을 도입할 기반도 마련되어 있습니다. 이를 통해 스타트업쇼는 스타트업과 VC 양측에게 유의미한 만남의 기회를 높여주고, 플랫폼에서 실제 투자 성사가 이루어질 가능성을 극대화합니다.

